

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>decitala.database &mdash; decitala 0.6.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> decitala
          

          
          </a>

          
            
            
              <div class="version">
                0.6.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../database.html">database.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fragment.html">fragment.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pofp.html">pofp.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trees.html">trees.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">utils.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../vis.html">vis.py</a></li>
</ul>
<p class="caption"><span class="caption-text">Rhythmic Fragments</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../decitalas.html">Desītālas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../greek_metrics.html">Greek Metrics</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">decitala</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>decitala.database</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for decitala.database</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">####################################################################################################</span>
<span class="c1"># File:     database.py</span>
<span class="c1"># Purpose:  Data structure for creating and representing databases using sqlite. </span>
<span class="c1"># </span>
<span class="c1"># Author:   Luke Poeppel</span>
<span class="c1">#</span>
<span class="c1"># Location: Kent, CT 2020 / Frankfurt, DE 2020</span>
<span class="c1">####################################################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for creating SQLite databases of extracted rhythmic data from Messiaen&#39;s music.  </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">import</span> <span class="nn">timeout_decorator</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="n">literal_eval</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">progress.bar</span> <span class="kn">import</span> <span class="n">Bar</span>
<span class="kn">from</span> <span class="nn">progress.spinner</span> <span class="kn">import</span> <span class="n">Spinner</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>

<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">converter</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">note</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">stream</span>

<span class="kn">from</span> <span class="nn">.fragment</span> <span class="kn">import</span> <span class="p">(</span>
	<span class="n">GeneralFragment</span><span class="p">,</span>
	<span class="n">Decitala</span><span class="p">,</span>
	<span class="n">GreekFoot</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
	<span class="n">get_object_indices</span><span class="p">,</span>
	<span class="n">successive_ratio_array</span><span class="p">,</span>
	<span class="n">successive_difference_array</span><span class="p">,</span>
	<span class="n">filter_single_anga_class_fragments</span><span class="p">,</span>
	<span class="n">filter_sub_fragments</span><span class="p">,</span>
	<span class="n">pitch_content_to_contour</span><span class="p">,</span>
	<span class="n">contour_to_prime_contour</span><span class="p">,</span> 
	<span class="n">get_logger</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.trees</span> <span class="kn">import</span> <span class="p">(</span>
	<span class="n">FragmentTree</span><span class="p">,</span>
	<span class="n">rolling_search</span><span class="p">,</span>
	<span class="n">filter_data</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.pofp</span> <span class="kn">import</span> <span class="p">(</span>
	<span class="n">get_break_points</span><span class="p">,</span>
	<span class="n">partition_data_by_break_points</span><span class="p">,</span>
	<span class="n">get_pareto_optimal_longest_paths</span>
<span class="p">)</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">mpl</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s2">&quot;seaborn&quot;</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
	<span class="s2">&quot;create_database&quot;</span><span class="p">,</span>
	<span class="s2">&quot;DBParser&quot;</span><span class="p">,</span>
	<span class="s2">&quot;create_fragment_database&quot;</span>
<span class="p">]</span>

<span class="c1"># Fragments</span>
<span class="n">here</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
<span class="n">decitala_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">here</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/Fragments/Decitalas&quot;</span>
<span class="n">greek_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">here</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/Fragments/Greek_Metrics/XML&quot;</span>

<span class="c1">############### EXCEPTIONS ###############</span>
<span class="k">class</span> <span class="nc">DatabaseException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
	<span class="k">pass</span>

<span class="k">def</span> <span class="nf">remove_cross_corpus_duplicates</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	&gt;&gt;&gt; fake_data = [</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.0, 0.5), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)], &quot;id&quot;:1},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GeneralFragment([0.25, 0.25], name=&quot;cs-test1&quot;), &#39;mod&#39;: (&#39;cs&#39;, 2.0), &#39;onset_range&#39;: (0.0, 0.5), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)], &quot;id&quot;:2},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Trochee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,)], &quot;id&quot;:3},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GeneralFragment([0.25, 0.125], name=&quot;cs-test2&quot;), &#39;mod&#39;: (&#39;cs&#39;, 2.0), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)], &quot;id&quot;:4},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Dactyl&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.5, 1.0), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,), (85,)], &quot;id&quot;:5},</span>
<span class="sd">	... 	{&#39;fragment&#39;: Decitala(&quot;Pratitala&quot;), &#39;mod&#39;: (&#39;d&#39;, 2.0), &#39;onset_range&#39;: (0.5, 1.0), &#39;is_spanned_by_slur&#39; : False, &#39;pitch_content&#39;: [(91,), (78,), (85,)], &quot;id&quot;:6}</span>
<span class="sd">	... ]</span>

<span class="sd">	This returns the following: (not evaluated because of random element...)</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Spondee&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.0, 0.5), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)], &#39;id&#39;: 1}</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GeneralFragment cs-test1: [0.25 0.25]&gt;, &#39;mod&#39;: (&#39;cs&#39;, 2.0), &#39;onset_range&#39;: (0.0, 0.5), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)], &#39;id&#39;: 2}</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Trochee&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,)], &#39;id&#39;: 3}</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GeneralFragment cs-test2: [0.25  0.125]&gt;, &#39;mod&#39;: (&#39;cs&#39;, 2.0), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)], &#39;id&#39;: 4}</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Dactyl&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.5, 1.0), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,), (85,)], &#39;id&#39;: 5}</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">onset_keyfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">]</span>
	<span class="n">onset_range_partition</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">onset_keyfunc</span><span class="p">)]</span>

	<span class="n">data_out</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">partition</span> <span class="ow">in</span> <span class="n">onset_range_partition</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">data_out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">cs_frags</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">partition</span> <span class="k">if</span> <span class="s2">&quot;cs&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;mod&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
			<span class="n">non_cs_frags</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">partition</span> <span class="k">if</span> <span class="s2">&quot;cs&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;mod&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
			<span class="n">data_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">non_cs_frags</span><span class="p">))</span>
			<span class="n">data_out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cs_frags</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">data_out</span>

<div class="viewcode-block" id="create_database"><a class="viewcode-back" href="../../database.html#decitala.database.create_database">[docs]</a><span class="nd">@timeout_decorator</span><span class="o">.</span><span class="n">timeout</span><span class="p">(</span><span class="mi">75</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">create_database</span><span class="p">(</span>
		<span class="n">db_path</span><span class="p">,</span>
		<span class="n">filepath</span><span class="p">,</span>
		<span class="n">part_num</span><span class="p">,</span>
		<span class="n">frag_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;decitala&quot;</span><span class="p">],</span>
		<span class="n">rep_types</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;ratio&quot;</span><span class="p">,</span> <span class="s2">&quot;difference&quot;</span><span class="p">],</span>
		<span class="n">allowed_modifications</span><span class="o">=</span><span class="p">[</span>
			<span class="s2">&quot;r&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;rr&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;d&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;rd&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;sr&quot;</span><span class="p">,</span> 
			<span class="s2">&quot;rsr&quot;</span>
		<span class="p">],</span>
		<span class="n">try_contiguous_summation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
		<span class="n">windows</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)),</span>
		<span class="n">allow_unnamed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
		<span class="n">filter_found_single_anga_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
		<span class="n">filter_found_sub_fragments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
		<span class="n">keep_grace_notes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
		<span class="n">write_logs_to_file</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
		<span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
	<span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This function generates an sqlite3 database for storing extracted rhythmic data from :obj:`decitala.trees.rolling_search`.</span>
<span class="sd">	The database holds has one page for storing all extracted fragments, their onsets/offsets of occurrence, and their </span>
<span class="sd">	modification data. </span>

<span class="sd">	:param str db_path: path where the .db file will be written. </span>
<span class="sd">	:param str filepath: path to score.</span>
<span class="sd">	:param int part_num: part number in the score. </span>
<span class="sd">	:param bool filter_single_anga_class: whether or not to remove single-anga class fragments from the data in rolling_search. </span>
<span class="sd">	:param boool filter_found_sub_fragments: whether or not to remove sub-fragments from the dataset. </span>
<span class="sd">	:param bool verbose: whether or not to log information about the database creation process (including data from rolling search). </span>
<span class="sd">	</span>
<span class="sd">	:return: sqlite3 database</span>
<span class="sd">	:rtype: .db file</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filepath</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The path provided is not a valid file.&quot;</span><span class="p">)</span>
		
	<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">db_path</span><span class="p">):</span>
		<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;That database already exists ✔&quot;</span><span class="p">)</span>
		<span class="k">return</span>

	<span class="n">filename</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">log_filepath</span> <span class="o">=</span> <span class="n">filepath</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">filename</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.txt&quot;</span>
	
	<span class="n">logger</span> <span class="o">=</span> <span class="n">get_logger</span><span class="p">(</span><span class="n">filepath</span><span class="o">=</span><span class="n">log_filepath</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">verbose</span><span class="p">):</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="n">logger</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
	
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Preparing database...&quot;</span><span class="p">)</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;File: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Part: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">part_num</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fragment types: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">frag_types</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Representation types: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rep_types</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Modifications: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">allowed_modifications</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Try contiguous summations: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">try_contiguous_summation</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Filter single anga class fragments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filter_found_single_anga_class</span><span class="p">))</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Filter sub fragments: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filter_found_sub_fragments</span><span class="p">))</span>
	<span class="c1"># logging.info(&quot;Keep grace notes: {}&quot;.format(keep_grace_notes))</span>

	<span class="n">ALL_DATA</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_frag_type</span> <span class="ow">in</span> <span class="n">frag_types</span><span class="p">:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Making fragment tree(s) (and searching) for frag_type: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_frag_type</span><span class="p">))</span>

		<span class="k">if</span> <span class="s2">&quot;ratio&quot;</span> <span class="ow">in</span> <span class="n">rep_types</span><span class="p">:</span>
			<span class="n">curr_ratio_tree</span> <span class="o">=</span> <span class="n">FragmentTree</span><span class="o">.</span><span class="n">from_frag_type</span><span class="p">(</span><span class="n">frag_type</span><span class="o">=</span><span class="n">this_frag_type</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="s2">&quot;ratio&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">curr_ratio_tree</span> <span class="o">=</span> <span class="kc">None</span>
		
		<span class="k">if</span> <span class="s2">&quot;difference&quot;</span> <span class="ow">in</span> <span class="n">rep_types</span><span class="p">:</span>
			<span class="n">curr_difference_tree</span> <span class="o">=</span> <span class="n">FragmentTree</span><span class="o">.</span><span class="n">from_frag_type</span><span class="p">(</span><span class="n">frag_type</span><span class="o">=</span><span class="n">this_frag_type</span><span class="p">,</span> <span class="n">rep_type</span><span class="o">=</span><span class="s2">&quot;difference&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">curr_difference_tree</span> <span class="o">=</span> <span class="kc">None</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">rolling_search</span><span class="p">(</span>
			<span class="n">filepath</span><span class="p">,</span>
			<span class="n">part_num</span><span class="p">,</span>
			<span class="n">curr_ratio_tree</span><span class="p">,</span>
			<span class="n">curr_difference_tree</span><span class="p">,</span>
			<span class="n">allowed_modifications</span><span class="p">,</span>
			<span class="n">try_contiguous_summation</span><span class="p">,</span>
			<span class="n">windows</span><span class="p">,</span>
			<span class="n">allow_unnamed</span><span class="p">,</span>
			<span class="n">verbose</span>
		<span class="p">)</span>

		<span class="n">ALL_DATA</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

	<span class="n">initial_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> fragments extracted&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">initial_length</span><span class="p">))</span>

	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing cross-corpus duplicates...&quot;</span><span class="p">)</span>
	<span class="n">ALL_DATA</span> <span class="o">=</span> <span class="n">remove_cross_corpus_duplicates</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)</span>

	<span class="c1">############ Filters ############</span>
	<span class="k">if</span> <span class="n">filter_found_single_anga_class</span><span class="p">:</span>
		<span class="n">ALL_DATA</span> <span class="o">=</span> <span class="n">filter_single_anga_class_fragments</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)</span>

		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing all single anga class fragments...&quot;</span><span class="p">)</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removed </span><span class="si">{0}</span><span class="s2"> fragments (</span><span class="si">{1}</span><span class="s2"> remaining)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">initial_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)))</span>
	
	<span class="n">new_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">filter_found_sub_fragments</span><span class="p">:</span>
		<span class="n">ALL_DATA</span> <span class="o">=</span> <span class="n">filter_sub_fragments</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing all sub fragments...&quot;</span><span class="p">)</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removed </span><span class="si">{0}</span><span class="s2"> fragments (</span><span class="si">{1}</span><span class="s2"> remaining)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)))</span>
	<span class="c1">#################################</span>

	<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculated break points: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">get_break_points</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">)))</span>

	<span class="n">all_object</span> <span class="o">=</span> <span class="n">get_object_indices</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">part_num</span><span class="p">)</span>
	<span class="n">sorted_onset_ranges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ALL_DATA</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
	<span class="n">partitioned_data</span> <span class="o">=</span> <span class="n">partition_data_by_break_points</span><span class="p">(</span><span class="n">sorted_onset_ranges</span><span class="p">)</span>

	<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
	<span class="k">with</span> <span class="n">conn</span><span class="p">:</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Connected to database at: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">db_path</span><span class="p">))</span>

		<span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
		
		<span class="c1">###### Creating Fragments Table ######</span>
		<span class="n">fragment_table_string</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE Fragments (Onset_Start REAL, Onset_Stop REAL, Fragment BLOB, Mod TEXT, Factor REAL, Pitch_Content BLOB, Pitch_Contour BLOB, Prime_Contour BLOB, Is_Slurred INT)&quot;</span>
		<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">fragment_table_string</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">this_fragment</span> <span class="ow">in</span> <span class="n">sorted_onset_ranges</span><span class="p">:</span>
			<span class="n">contour</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pitch_content_to_contour</span><span class="p">(</span><span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;pitch_content&quot;</span><span class="p">]))</span>
			<span class="n">prime_contour</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">contour_to_prime_contour</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">include_depth</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
			<span class="n">fragment_insertion_string</span> <span class="o">=</span> <span class="s2">&quot;INSERT INTO Fragments VALUES(</span><span class="si">{0}</span><span class="s2">, </span><span class="si">{1}</span><span class="s2">, &#39;</span><span class="si">{2}</span><span class="s2">&#39;, &#39;</span><span class="si">{3}</span><span class="s2">&#39;, </span><span class="si">{4}</span><span class="s2">, &#39;</span><span class="si">{5}</span><span class="s2">&#39;, &#39;</span><span class="si">{6}</span><span class="s2">&#39;, &#39;</span><span class="si">{7}</span><span class="s2">&#39;, </span><span class="si">{8}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="c1"># start offset</span>
																												<span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># end offset</span>
																												<span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="c1"># fragment</span>
																												<span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;mod&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="c1"># mod type </span>
																												<span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;mod&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># mod factor/difference</span>
																												<span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;pitch_content&quot;</span><span class="p">],</span> <span class="c1"># pitch content</span>
																												<span class="n">contour</span><span class="p">,</span> <span class="c1"># pitch contour </span>
																												<span class="n">prime_contour</span><span class="p">,</span> <span class="c1"># prime contour</span>
																												<span class="nb">int</span><span class="p">(</span><span class="n">this_fragment</span><span class="p">[</span><span class="s2">&quot;is_spanned_by_slur&quot;</span><span class="p">]))</span> <span class="c1"># is_slurred</span>
			<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">fragment_insertion_string</span><span class="p">)</span>

		<span class="c1">###### Creating Paths Table ######</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_partition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">partitioned_data</span><span class="p">):</span>			
			<span class="n">pareto_optimal_paths</span> <span class="o">=</span> <span class="n">get_pareto_optimal_longest_paths</span><span class="p">(</span><span class="n">this_partition</span><span class="p">)</span>
			<span class="n">longest_path</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pareto_optimal_paths</span><span class="p">])</span>

			<span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Onset_Range_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">longest_path</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
			<span class="n">columns_declaration</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> INTEGER&quot;</span> <span class="o">%</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">)</span>

			<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE Paths_</span><span class="si">{0}</span><span class="s2"> (</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">columns_declaration</span><span class="p">))</span>
			<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Making Paths_</span><span class="si">{}</span><span class="s2"> table&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			
			<span class="n">FRAGMENT_TABLE_STRING</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM Fragments&quot;</span>
			<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">FRAGMENT_TABLE_STRING</span><span class="p">)</span>
			<span class="n">fragment_rows</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
			<span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">pareto_optimal_paths</span><span class="p">:</span>
				<span class="n">fragment_row_ids</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">this_fragment_data</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
					<span class="n">data</span> <span class="o">=</span> <span class="n">this_fragment_data</span>
					<span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">this_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fragment_rows</span><span class="p">):</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
							<span class="n">fragment_row_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="n">longest_path</span><span class="p">:</span>
					<span class="n">longest_paths_insertion_string</span> <span class="o">=</span> <span class="s2">&quot;INSERT INTO Paths_</span><span class="si">{0}</span><span class="s2"> VALUES(</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fragment_row_ids</span><span class="p">]))</span>
					<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">longest_paths_insertion_string</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">diff</span> <span class="o">=</span> <span class="n">longest_path</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
					<span class="n">nulls</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&#39;NULL&#39;&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">diff</span>
					<span class="n">combined</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fragment_row_ids</span><span class="p">]</span> <span class="o">+</span> <span class="n">nulls</span>					
					<span class="n">shorter_paths_values_string</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>

					<span class="n">shorter_paths_insertion_string</span> <span class="o">=</span> <span class="s2">&quot;INSERT INTO Paths_</span><span class="si">{0}</span><span class="s2"> VALUES(</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">shorter_paths_values_string</span><span class="p">)</span>
					<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">shorter_paths_insertion_string</span><span class="p">)</span>
		
		<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done preparing ✔&quot;</span><span class="p">)</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># Helper functions</span>
<span class="k">def</span> <span class="nf">_num_subpath_tables</span><span class="p">(</span><span class="n">conn</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns the number of Path tables in a database db.</span>
<span class="sd">	</span>
<span class="sd">	&gt;&gt;&gt; example_data = &quot;./tests/static/ex99_data.db&quot;	</span>
<span class="sd">	&gt;&gt;&gt; conn = sqlite3.connect(example_data)</span>
<span class="sd">	&gt;&gt;&gt; _num_subpath_tables(conn)</span>
<span class="sd">	1</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">QUERY_STRING</span> <span class="o">=</span> <span class="s2">&quot;SELECT COUNT(*) FROM sqlite_master WHERE type = &#39;table&#39;&quot;</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">QUERY_STRING</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
	<span class="n">num_path_tables</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;COUNT(*)&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

	<span class="k">return</span> <span class="n">num_path_tables</span>

<span class="k">def</span> <span class="nf">_num_rows_in_table</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">conn</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns the number of rows in a given table.</span>
<span class="sd">	</span>
<span class="sd">	&gt;&gt;&gt; example_data = &quot;./tests/static/ex99_data.db&quot;</span>
<span class="sd">	&gt;&gt;&gt; conn = sqlite3.connect(example_data)</span>
<span class="sd">	&gt;&gt;&gt; _num_rows_in_table(&quot;Paths_1&quot;, conn)</span>
<span class="sd">	1265</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">QUERY_STRING</span> <span class="o">=</span> <span class="s2">&quot;SELECT COUNT(*) FROM </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">QUERY_STRING</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
	<span class="n">num_rows</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;COUNT(*)&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	
	<span class="k">return</span> <span class="n">num_rows</span>

<div class="viewcode-block" id="DBParser"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser">[docs]</a><span class="k">class</span> <span class="nc">DBParser</span><span class="p">:</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Class used for parsing the SQLite database made in :obj:`~decitala.database.create_database`.</span>

<span class="sd">	&gt;&gt;&gt; example_data = &quot;./databases/liturgie_3.db&quot;</span>
<span class="sd">	&gt;&gt;&gt; lit_db = DBParser(example_data)</span>
<span class="sd">	&gt;&gt;&gt; lit_db</span>
<span class="sd">	&lt;database.DBParser liturgie_3.db&gt;</span>
<span class="sd">	&gt;&gt;&gt; for frag in lit_db.fragments()[0:5]:</span>
<span class="sd">	... 	print(frag)</span>
<span class="sd">	&lt;fragment.Decitala 93_Ragavardhana&gt;</span>
<span class="sd">	&lt;fragment.Decitala 43_Malikamoda&gt;</span>
<span class="sd">	&lt;fragment.Decitala 105_Candrakala&gt;</span>
<span class="sd">	&lt;fragment.Decitala 47_Makaranda&gt;</span>
<span class="sd">	&lt;fragment.Decitala 88_Lakskmica&gt;</span>
<span class="sd">	&gt;&gt;&gt; lit_db.num_subpath_tables</span>
<span class="sd">	10</span>
<span class="sd">	&gt;&gt;&gt; lit_db.subpath(8, 2)</span>
<span class="sd">	[41, 43, 46]</span>
<span class="sd">	&gt;&gt;&gt; for data in lit_db.subpath_data(8, 2):</span>
<span class="sd">	... 	print(data[&quot;fragment&quot;], data[&quot;onset_range&quot;])</span>
<span class="sd">	&lt;fragment.Decitala 88_Lakskmica&gt; (88.75, 93.0)</span>
<span class="sd">	&lt;fragment.Decitala 93_Ragavardhana&gt; (93.0, 97.75)</span>
<span class="sd">	&lt;fragment.Decitala 47_Makaranda&gt; (98.25, 101.5)</span>
<span class="sd">	&gt;&gt;&gt; lit_db.subpath_intra_gap_score(8, 2)</span>
<span class="sd">	95.91836734693878</span>
<span class="sd">	&gt;&gt;&gt; lit_db.subpath_onset_percentile(8, 2)</span>
<span class="sd">	33.333333333333336</span>
<span class="sd">	&gt;&gt;&gt; # the model requires weights (for table num &gt; 1, 2 values). </span>
<span class="sd">	&gt;&gt;&gt; lit_db.intra_subpath_model_score(8, 2, weights=[0.7, 0.3])</span>
<span class="sd">	77.14285714285714</span>
<span class="sd">	&gt;&gt;&gt; # for table num == 1, it requires 3 weights: </span>
<span class="sd">	&gt;&gt;&gt; lit_db.intra_subpath_model_score(1, 1, weights=[0.5, 0.3, 0.2])</span>
<span class="sd">	90.0</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_path</span><span class="p">):</span>
		<span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">db_path</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;You&#39;ve provided an invalid file.&quot;</span><span class="p">)</span>

		<span class="n">filename</span> <span class="o">=</span> <span class="n">db_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">db_path</span> <span class="o">=</span> <span class="n">db_path</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span>

		<span class="n">fragment_path_string</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM Fragments&quot;</span>
		<span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">fragment_path_string</span><span class="p">)</span>
		<span class="n">fragment_rows</span> <span class="o">=</span> <span class="n">cur</span><span class="o">.</span><span class="n">fetchall</span><span class="p">()</span>
		<span class="n">fragment_data</span> <span class="o">=</span> <span class="p">[]</span>

		<span class="n">earliest_detected_onset</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># random starting value.</span>

		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fragment_rows</span><span class="p">):</span>
			<span class="n">row_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

			<span class="n">fragment_str</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">fragment_str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
				<span class="n">this_fragment</span> <span class="o">=</span> <span class="n">Decitala</span><span class="p">(</span><span class="n">fragment_str</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">this_fragment</span> <span class="o">=</span> <span class="n">GreekFoot</span><span class="p">(</span><span class="n">fragment_str</span><span class="p">)</span>

			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;db_row_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_fragment</span>
			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;mod&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;factor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_row</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;pitch_content&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">literal_eval</span><span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
			<span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;is_slurred&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">this_row</span><span class="p">[</span><span class="mi">8</span><span class="p">]))</span>

			<span class="k">if</span> <span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">earliest_detected_onset</span><span class="p">:</span>
				<span class="n">earliest_detected_onset</span> <span class="o">=</span> <span class="n">row_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
			
			<span class="n">fragment_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">fragment_data</span> <span class="o">=</span> <span class="n">fragment_data</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">earliest_detected_onset</span> <span class="o">=</span> <span class="n">earliest_detected_onset</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">num_subpath_tables</span> <span class="o">=</span> <span class="n">_num_subpath_tables</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_subpath_tables</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
			<span class="n">num_rows</span> <span class="o">=</span> <span class="n">_num_rows_in_table</span><span class="p">(</span><span class="s2">&quot;Paths_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
			<span class="n">onset_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table_average_onsets_per_fragment_per_subpath</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
			<span class="n">metadata</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span> <span class="n">onset_data</span><span class="p">])</span>

		<span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">metadata</span>

	<span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s2">&quot;&lt;database.DBParser </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="DBParser.fragments"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.fragments">[docs]</a>	<span class="k">def</span> <span class="nf">fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:return: list of all extracted fragments in the database. </span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_data</span><span class="p">]</span></div>

<div class="viewcode-block" id="DBParser.slurred_fragments"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.slurred_fragments">[docs]</a>	<span class="k">def</span> <span class="nf">slurred_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:return: the complete data for the extracted fragments that are slurred.</span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_data</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;is_slurred&quot;</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">]</span></div>

	<span class="c1">######## Visualization ########</span>
<div class="viewcode-block" id="DBParser.show_fragments_table"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.show_fragments_table">[docs]</a>	<span class="k">def</span> <span class="nf">show_fragments_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Displays the Fragments table of the database.</span>

<span class="sd">		:return: the fragments table (as a dataframe). </span>
<span class="sd">		:rtype: pandas.DataFrame </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM Fragments&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">data</span></div>
	
<div class="viewcode-block" id="DBParser.show_slurred_fragments"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.show_slurred_fragments">[docs]</a>	<span class="k">def</span> <span class="nf">show_slurred_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Displays the slurred fragments in the Fragments table of the database.</span>
<span class="sd">		</span>
<span class="sd">		:return: the subset of slurred fragments in the fragments table (as a dataframe). </span>
<span class="sd">		:rtype: pandas.DataFrame </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM Fragments WHERE Is_Slurred = 1&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="DBParser.show_subpath_table"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.show_subpath_table">[docs]</a>	<span class="k">def</span> <span class="nf">show_subpath_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Displays the queried subpath table. These subpath tables are 1-indexed.</span>
<span class="sd">		</span>
<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:return: the queried subpath tale (as a dataframe).</span>
<span class="sd">		:rtype: pandas.DataFrame</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		
		<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM Paths_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_num</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="DBParser.show_subpath"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.show_subpath">[docs]</a>	<span class="k">def</span> <span class="nf">show_subpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Displays a queried subpath in one of the tables. </span>
<span class="sd">		</span>
<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:return: the queried subpath table (as a dataframe).</span>
<span class="sd">		:rtype: pandas.DataFrame</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		
		<span class="n">QUERY_STRING</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM Paths_</span><span class="si">{0}</span><span class="s2"> WHERE rowid = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">QUERY_STRING</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">data</span></div>
	
	<span class="k">def</span> <span class="nf">show_subpath_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>

		<span class="n">fragment_row_ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">))</span>
		<span class="n">QUERY_STRING</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM Fragments WHERE rowid IN </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fragment_row_ids</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">QUERY_STRING</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">data</span>

	<span class="c1">######## Paths Individual ########</span>
<div class="viewcode-block" id="DBParser.subpath"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.subpath">[docs]</a>	<span class="k">def</span> <span class="nf">subpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the SQLite rowids for the fragments in a subpath. </span>
<span class="sd">		</span>
<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:return: the rowids (int) for the fragments in a subpath.</span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>

		<span class="n">QUERY_STRING</span> <span class="o">=</span> <span class="s2">&quot;SELECT * FROM Paths_</span><span class="si">{0}</span><span class="s2"> WHERE rowid = </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_sql_query</span><span class="p">(</span><span class="n">QUERY_STRING</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="n">as_ints</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
		
		<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">as_ints</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s2">&quot;NULL&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="DBParser.subpath_data"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.subpath_data">[docs]</a>	<span class="k">def</span> <span class="nf">subpath_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the full extracted fragment data in a given subpath.</span>
<span class="sd">		</span>
<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:return: the complete fragment data for a subpath</span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>

		<span class="n">subpath_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		
		<span class="n">fragment_data</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">this_row_id</span> <span class="ow">in</span> <span class="n">subpath_data</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">this_data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_data</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">this_data</span><span class="p">[</span><span class="s2">&quot;db_row_index&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_row_id</span><span class="p">:</span>
					<span class="n">fragment_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_data</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">fragment_data</span></div>
	
	<span class="c1">#####################################################################################</span>
<div class="viewcode-block" id="DBParser.table_average_onsets_per_fragment_per_subpath"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.table_average_onsets_per_fragment_per_subpath">[docs]</a>	<span class="k">def</span> <span class="nf">table_average_onsets_per_fragment_per_subpath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		This is a bit hacky: this method is called in the __init__ and returns the average</span>
<span class="sd">		number of onsets for each fragment in each subpath of the table. Thus, if a paths</span>
<span class="sd">		table has 3 rows, this method returns a list of 3 numbers, each of which corresponds</span>
<span class="sd">		to the average number of onsets in a fragment in that subpath. </span>

<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:return: list (of length equal to the number of rows in the queried ``Paths`` table) </span>
<span class="sd">				holding the average number of onsets (type: float) for a fragment in each subpath. </span>
<span class="sd">		:rtype: list</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		
		<span class="n">num_rows</span> <span class="o">=</span> <span class="n">_num_rows_in_table</span><span class="p">(</span><span class="s2">&quot;Paths_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_num</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="n">averages</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
			<span class="n">subpath_fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">num_onsets</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
			<span class="n">averages</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">subpath_fragments</span><span class="p">))</span>
		
		<span class="k">return</span> <span class="n">averages</span></div>

	<span class="c1">#####################################################################################</span>
	<span class="c1"># Modeling</span>
<div class="viewcode-block" id="DBParser.subpath_onset_percentile"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.subpath_onset_percentile">[docs]</a>	<span class="k">def</span> <span class="nf">subpath_onset_percentile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Given the data from :obj:`~decitala.database.DBParser.table_average_onsets_per_fragment_per_subpath`, gets the </span>
<span class="sd">		percentile of a given subpath. </span>

<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:return: percentile (0-100) of a given subpath in the context of its full ``Paths`` table. </span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		
		<span class="n">subpath_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		<span class="n">subpath_average_onsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">num_onsets</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subpath_data</span><span class="p">])</span>
		
		<span class="c1"># NOTE: I call metadata instead of the above function as it then doesn&#39;t need to be recalulated. </span>
		<span class="n">onset_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">table_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
		<span class="n">percentile</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">percentileofscore</span><span class="p">(</span><span class="n">onset_data</span><span class="p">,</span> <span class="n">subpath_average_onsets</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">percentile</span></div>

<div class="viewcode-block" id="DBParser.first_subpath_start_gap_score"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.first_subpath_start_gap_score">[docs]</a>	<span class="k">def</span> <span class="nf">first_subpath_start_gap_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:return: the proportion of the starting gap (i.e. the empty region from the earliest detected onset in the table</span>
<span class="sd">				to the start of the queried subpath) to the total range of the queried subpath in the first table. </span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">first_subpath_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">path_num</span><span class="o">=</span><span class="n">path_num</span><span class="p">)</span>
		<span class="n">starting_onset</span> <span class="o">=</span> <span class="n">first_subpath_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">ending_onset</span> <span class="o">=</span> <span class="n">first_subpath_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">total_range</span> <span class="o">=</span> <span class="n">ending_onset</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">earliest_detected_onset</span>

		<span class="n">gap</span> <span class="o">=</span> <span class="n">starting_onset</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">earliest_detected_onset</span>
		<span class="n">gap_proportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">gap</span> <span class="o">/</span> <span class="n">total_range</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>

		<span class="k">return</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">gap_proportion</span></div>

<div class="viewcode-block" id="DBParser.subpath_intra_gap_score"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.subpath_intra_gap_score">[docs]</a>	<span class="k">def</span> <span class="nf">subpath_intra_gap_score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the proportion of gaps in a subpath.</span>
<span class="sd">		</span>
<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:return: proportion of the total gaps between fragments in a subpath to the total range of the subpath. </span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		
		<span class="n">gaps</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">total_range</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">subpath_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpath_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">curr_data</span> <span class="o">=</span> <span class="n">subpath_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
			<span class="n">next_data</span><span class="o">=</span> <span class="n">subpath_data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
			
			<span class="n">gap</span> <span class="o">=</span> <span class="n">next_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
			<span class="n">gaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>
			<span class="n">total_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">curr_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpath_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
				<span class="n">total_range</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">next_data</span><span class="p">[</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
		
		<span class="n">gaps</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
		<span class="n">total_range</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">total_range</span><span class="p">)</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subpath_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">gap_proportion</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">gap_proportion</span> <span class="o">=</span> <span class="p">(</span><span class="n">gaps</span> <span class="o">/</span> <span class="n">total_range</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
		
		<span class="n">percentage_gap</span> <span class="o">=</span> <span class="mf">100.0</span> <span class="o">-</span> <span class="n">gap_proportion</span>
		<span class="k">return</span> <span class="n">percentage_gap</span></div>
		
<div class="viewcode-block" id="DBParser.subpath_inter_gap_score"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.subpath_inter_gap_score">[docs]</a>	<span class="k">def</span> <span class="nf">subpath_inter_gap_score</span><span class="p">(</span>
			<span class="bp">self</span><span class="p">,</span> 
			<span class="n">table_num_a</span><span class="p">,</span> 
			<span class="n">path_num_a</span><span class="p">,</span> 
			<span class="n">table_num_b</span><span class="p">,</span> 
			<span class="n">path_num_b</span>
		<span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the proportion of the gap between two subpaths to the whole range of the paths. </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">data_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num_a</span><span class="p">,</span> <span class="n">path_num_a</span><span class="p">)</span>
		<span class="n">data_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num_b</span><span class="p">,</span> <span class="n">path_num_b</span><span class="p">)</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">data_a</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">data_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">total_range</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>

		<span class="n">gap_start</span> <span class="o">=</span> <span class="n">data_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">gap_stop</span> <span class="o">=</span> <span class="n">data_b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;onset_range&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">gap</span> <span class="o">=</span> <span class="n">gap_stop</span> <span class="o">-</span> <span class="n">gap_start</span>
		
		<span class="n">inter_gap_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">gap</span> <span class="o">/</span> <span class="n">total_range</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
		<span class="k">return</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">inter_gap_score</span></div>

	<span class="c1">#####################################################################################</span>
<div class="viewcode-block" id="DBParser.intra_subpath_model_score"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.intra_subpath_model_score">[docs]</a>	<span class="k">def</span> <span class="nf">intra_subpath_model_score</span><span class="p">(</span>
			<span class="bp">self</span><span class="p">,</span> 
			<span class="n">table_num</span><span class="p">,</span> 
			<span class="n">path_num</span><span class="p">,</span> 
			<span class="n">weights</span>
		<span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param int path_num: 1-indexed subpath number. </span>
<span class="sd">		:param list weights: intra-subpath weights.  </span>
<span class="sd">		:return: returns the intra-subpath model score. </span>
<span class="sd">		:rtype: float</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="p">(</span><span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">path_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num and path_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">table_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;For the first table, three weights must be provided.&quot;</span><span class="p">)</span>

		<span class="n">gap_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_intra_gap_score</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		<span class="n">onset_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_onset_percentile</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">path_num</span><span class="p">)</span>
		<span class="n">model</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">if</span> <span class="n">table_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">start_gap_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first_subpath_start_gap_score</span><span class="p">(</span><span class="n">path_num</span><span class="p">)</span>
			<span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">gap_score</span><span class="p">,</span> <span class="n">onset_score</span><span class="p">,</span> <span class="n">start_gap_score</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
				<span class="n">model</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">score</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">gap_score</span><span class="p">,</span> <span class="n">onset_score</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">weight</span><span class="p">,</span> <span class="n">score</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">scores</span><span class="p">):</span>
				<span class="n">model</span> <span class="o">+=</span> <span class="n">weight</span> <span class="o">*</span> <span class="n">score</span>

		<span class="k">return</span> <span class="n">model</span></div>
	
<div class="viewcode-block" id="DBParser.highest_modeled_subpath"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.highest_modeled_subpath">[docs]</a>	<span class="k">def</span> <span class="nf">highest_modeled_subpath</span><span class="p">(</span>
			<span class="bp">self</span><span class="p">,</span> 
			<span class="n">table_num</span><span class="p">,</span>
			<span class="n">weights</span>
		<span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Gets the highest modeled subpath in the table.</span>

<span class="sd">		:param int table_num: 1-indexed table number. </span>
<span class="sd">		:param list weights: intra-subpath weights. </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="n">table_num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">DatabaseException</span><span class="p">(</span><span class="s2">&quot;The table_num must be &gt;= 1.&quot;</span><span class="p">)</span>
		
		<span class="n">num_rows</span> <span class="o">=</span> <span class="n">_num_rows_in_table</span><span class="p">(</span><span class="s2">&quot;Paths_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_num</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="p">)</span>
		<span class="n">highest_subpath</span> <span class="o">=</span> <span class="kc">None</span>
		<span class="n">highest_model_val</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
			<span class="n">model_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intra_subpath_model_score</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">model_val</span> <span class="o">&gt;</span> <span class="n">highest_model_val</span><span class="p">:</span>
				<span class="n">highest_model_val</span> <span class="o">=</span> <span class="n">model_val</span>
				<span class="n">highest_subpath</span> <span class="o">=</span> <span class="n">i</span>

		<span class="k">return</span> <span class="n">highest_subpath</span></div>

<div class="viewcode-block" id="DBParser.model_full_path"><a class="viewcode-back" href="../../database.html#decitala.database.DBParser.model_full_path">[docs]</a>	<span class="k">def</span> <span class="nf">model_full_path</span><span class="p">(</span>
			<span class="bp">self</span><span class="p">,</span>
			<span class="n">start_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> 
			<span class="n">rest_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> 
			<span class="n">intra_inter_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]</span>
		<span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		Return list of highest modeled subpath nums for each table. </span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="n">table_num</span> <span class="o">=</span> <span class="mi">1</span>
		<span class="k">while</span> <span class="n">table_num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">table_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">highest_first_subpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highest_modeled_subpath</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">start_weights</span><span class="p">)</span>
				<span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">highest_first_subpath</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">last</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
				<span class="n">curr_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="p">[</span><span class="n">table_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
				<span class="n">scores</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">row_num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curr_data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
					<span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">row_num</span><span class="p">)]</span>
					<span class="n">intra_model_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intra_subpath_model_score</span><span class="p">(</span><span class="n">table_num</span><span class="p">,</span> <span class="n">row_num</span><span class="p">,</span> <span class="n">rest_weights</span><span class="p">)</span>
					<span class="n">inter_subpath_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subpath_inter_gap_score</span><span class="p">(</span><span class="n">table_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">table_num</span><span class="p">,</span> <span class="n">row_num</span><span class="p">)</span>
					<span class="n">combined</span> <span class="o">=</span> <span class="p">(</span><span class="n">intra_inter_weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">intra_model_score</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">intra_inter_weights</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">inter_subpath_score</span><span class="p">)</span>
					<span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span>
				
				<span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">scores</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
			
			<span class="n">table_num</span> <span class="o">+=</span> <span class="mi">1</span>
			
		<span class="k">return</span> <span class="n">path</span></div>
	
	<span class="k">def</span> <span class="nf">path_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row_nums</span><span class="p">):</span>
		<span class="n">full_data</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row_num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row_nums</span><span class="p">):</span>
			<span class="n">full_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subpath_data</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">row_num</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">full_data</span></div>
	
<span class="c1">####################################################################################################</span>
<span class="c1"># Fragment Databases</span>
<span class="sd">&quot;&quot;&quot;The following function is used to create the databases for fragment querying.&quot;&quot;&quot;</span>
<span class="c1"># Helpers</span>
<span class="k">def</span> <span class="nf">_get_initial_data</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">log_msg</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Reads the initial data from the input directory.&quot;&quot;&quot;</span>
	<span class="n">initial_data</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">with</span> <span class="n">Bar</span><span class="p">(</span><span class="n">log_msg</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">size</span><span class="p">)</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">this_file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
			<span class="n">filename</span> <span class="o">=</span> <span class="n">this_file</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>
			<span class="n">converted</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">path</span><span class="p">,</span> <span class="n">this_file</span><span class="p">]))</span>
			<span class="n">ql_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">this_note</span><span class="o">.</span><span class="n">quarterLength</span> <span class="k">for</span> <span class="n">this_note</span> <span class="ow">in</span> <span class="n">converted</span><span class="o">.</span><span class="n">flat</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">note</span><span class="o">.</span><span class="n">Note</span><span class="p">)]</span>
			
			<span class="n">frag_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
			<span class="n">frag_dict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filename</span>
			<span class="n">frag_dict</span><span class="p">[</span><span class="s2">&quot;ql_array&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ql_array</span>
			<span class="n">frag_dict</span><span class="p">[</span><span class="s2">&quot;r_equivalents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="n">frag_dict</span><span class="p">[</span><span class="s2">&quot;r_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># arbitrary starting value</span>
			<span class="n">frag_dict</span><span class="p">[</span><span class="s2">&quot;d_equivalents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="n">frag_dict</span><span class="p">[</span><span class="s2">&quot;d_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="c1"># arbitrary starting value</span>
			
			<span class="n">initial_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frag_dict</span><span class="p">)</span>
			<span class="n">bar</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">initial_data</span>

<span class="k">def</span> <span class="nf">_track_rd_equivalents</span><span class="p">(</span><span class="n">dataset_a</span><span class="p">,</span> <span class="n">dataset_b</span><span class="p">,</span> <span class="n">dataset_b_frag_type</span><span class="p">):</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset_a</span><span class="p">):</span>
		<span class="n">curr_fragment</span> <span class="o">=</span> <span class="n">dataset_a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">curr_ql_array</span> <span class="o">=</span> <span class="n">curr_fragment</span><span class="p">[</span><span class="s2">&quot;ql_array&quot;</span><span class="p">]</span>
		<span class="n">curr_rarray</span> <span class="o">=</span> <span class="n">successive_ratio_array</span><span class="p">(</span><span class="n">curr_ql_array</span><span class="p">)</span>
		<span class="n">curr_darray</span> <span class="o">=</span> <span class="n">successive_difference_array</span><span class="p">(</span><span class="n">curr_ql_array</span><span class="p">)</span>
		<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset_b</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
				<span class="k">pass</span> <span class="c1"># i.e. skip curr step. </span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">other_fragment</span> <span class="o">=</span> <span class="n">dataset_b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
				<span class="n">other_ql_array</span> <span class="o">=</span> <span class="n">other_fragment</span><span class="p">[</span><span class="s2">&quot;ql_array&quot;</span><span class="p">]</span>
				<span class="n">other_rarray</span> <span class="o">=</span> <span class="n">successive_ratio_array</span><span class="p">(</span><span class="n">other_ql_array</span><span class="p">)</span>
				<span class="n">other_darray</span> <span class="o">=</span> <span class="n">successive_difference_array</span><span class="p">(</span><span class="n">other_ql_array</span><span class="p">)</span>
				
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">curr_rarray</span><span class="p">,</span> <span class="n">other_rarray</span><span class="p">):</span>
					<span class="n">curr_fragment</span><span class="p">[</span><span class="s2">&quot;r_equivalents&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dataset_b_frag_type</span><span class="p">,</span> <span class="n">other_fragment</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>
				<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">curr_darray</span><span class="p">,</span> <span class="n">other_darray</span><span class="p">):</span>
					<span class="n">curr_fragment</span><span class="p">[</span><span class="s2">&quot;d_equivalents&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dataset_b_frag_type</span><span class="p">,</span> <span class="n">other_fragment</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>	
			<span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">return</span> <span class="n">dataset_a</span>

<span class="k">def</span> <span class="nf">_track_keep_vals</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">frag_type</span><span class="p">):</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
		<span class="n">curr_frag_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">r_equivalent_fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">curr_frag_data</span><span class="p">[</span><span class="s2">&quot;r_equivalents&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">frag_type</span><span class="p">]</span>
		<span class="n">d_equivalent_fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">curr_frag_data</span><span class="p">[</span><span class="s2">&quot;d_equivalents&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">frag_type</span><span class="p">]</span>

		<span class="k">if</span> <span class="n">curr_frag_data</span><span class="p">[</span><span class="s2">&quot;r_keep&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
			<span class="n">curr_frag_data</span><span class="p">[</span><span class="s2">&quot;r_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">r_equivalent_fragments</span><span class="p">):</span>
				<span class="k">pass</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">this_fragment</span> <span class="ow">in</span> <span class="n">r_equivalent_fragments</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">this_other_fragment</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">this_other_fragment</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_fragment</span><span class="p">:</span>
							<span class="n">this_other_fragment</span><span class="p">[</span><span class="s2">&quot;r_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">pass</span>

		<span class="k">if</span> <span class="n">curr_frag_data</span><span class="p">[</span><span class="s2">&quot;d_keep&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
			<span class="n">curr_frag_data</span><span class="p">[</span><span class="s2">&quot;d_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">d_equivalent_fragments</span><span class="p">):</span>
				<span class="k">pass</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">this_fragment</span> <span class="ow">in</span> <span class="n">d_equivalent_fragments</span><span class="p">:</span>
					<span class="k">for</span> <span class="n">this_other_fragment</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">this_other_fragment</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_fragment</span><span class="p">:</span>
							<span class="n">this_other_fragment</span><span class="p">[</span><span class="s2">&quot;d_keep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">pass</span>

		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">return</span> <span class="n">data</span>

<span class="k">def</span> <span class="nf">_make_table</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">conn</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Function for creating a fragments table in the connected SQL database.&quot;&quot;&quot;</span>
	<span class="n">table_string</span> <span class="o">=</span> <span class="s2">&quot;CREATE TABLE </span><span class="si">{}</span><span class="s2"> (Name BLOB, QL_Array BLOB, R_Equivalents BLOB, D_Equivalents BLOB, R_Keep INT, D_Keep INT)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
	<span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">table_string</span><span class="p">)</span>

	<span class="k">with</span> <span class="n">Bar</span><span class="p">(</span><span class="s2">&quot;Making </span><span class="si">{}</span><span class="s2"> Table...&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_name</span><span class="p">),</span> <span class="nb">max</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">as</span> <span class="n">bar</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">this_fragment_data</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
			<span class="n">name</span> <span class="o">=</span> <span class="n">this_fragment_data</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
			<span class="n">ql_array</span> <span class="o">=</span> <span class="n">this_fragment_data</span><span class="p">[</span><span class="s2">&quot;ql_array&quot;</span><span class="p">]</span>
			<span class="n">r_equivalents</span> <span class="o">=</span> <span class="n">this_fragment_data</span><span class="p">[</span><span class="s2">&quot;r_equivalents&quot;</span><span class="p">]</span>
			<span class="n">d_equivalents</span> <span class="o">=</span> <span class="n">this_fragment_data</span><span class="p">[</span><span class="s2">&quot;d_equivalents&quot;</span><span class="p">]</span>
			<span class="n">r_keep</span> <span class="o">=</span> <span class="n">this_fragment_data</span><span class="p">[</span><span class="s2">&quot;r_keep&quot;</span><span class="p">]</span>
			<span class="n">d_keep</span> <span class="o">=</span> <span class="n">this_fragment_data</span><span class="p">[</span><span class="s2">&quot;d_keep&quot;</span><span class="p">]</span>

			<span class="n">fragment_insertion_string</span> <span class="o">=</span> <span class="s2">&quot;INSERT INTO </span><span class="si">{0}</span><span class="s2"> VALUES(&#39;</span><span class="si">{1}</span><span class="s2">&#39;, ?, ?, ?, ?, ?)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
			<span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">fragment_insertion_string</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">ql_array</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">r_equivalents</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">d_equivalents</span><span class="p">),</span> <span class="n">r_keep</span><span class="p">,</span> <span class="n">d_keep</span><span class="p">))</span>
			<span class="n">bar</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_create_fragment_database</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Dataset counts: 130 Decitalas, 26 Greek Metrics.&quot;&quot;&quot;</span>
	<span class="n">db_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">here</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;/databases/fragment_database.db&quot;</span>
	
	<span class="n">decitala_initial_data</span> <span class="o">=</span> <span class="n">_get_initial_data</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">decitala_path</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">130</span><span class="p">,</span> <span class="n">log_msg</span><span class="o">=</span><span class="s2">&quot;Getting initial decitala data...&quot;</span><span class="p">)</span>	
	<span class="n">greek_metric_initial_data</span> <span class="o">=</span> <span class="n">_get_initial_data</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">greek_path</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">26</span><span class="p">,</span> <span class="n">log_msg</span><span class="o">=</span><span class="s2">&quot;Getting initial greek metric data...&quot;</span><span class="p">)</span>

	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tracking intra-level decitala equivalents...&quot;</span><span class="p">)</span>
	<span class="n">decitala_intra_equivalents</span> <span class="o">=</span> <span class="n">_track_rd_equivalents</span><span class="p">(</span>
		<span class="n">dataset_a</span><span class="o">=</span><span class="n">decitala_initial_data</span><span class="p">,</span> 
		<span class="n">dataset_b</span><span class="o">=</span><span class="n">decitala_initial_data</span><span class="p">,</span> 
		<span class="n">dataset_b_frag_type</span><span class="o">=</span><span class="s2">&quot;decitala&quot;</span>
	<span class="p">)</span>
	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tracking cross-corpus decitala equivalents...&quot;</span><span class="p">)</span>
	<span class="n">decitala_cross_equivalents</span> <span class="o">=</span> <span class="n">_track_rd_equivalents</span><span class="p">(</span>
		<span class="n">dataset_a</span><span class="o">=</span><span class="n">decitala_intra_equivalents</span><span class="p">,</span> 
		<span class="n">dataset_b</span><span class="o">=</span><span class="n">greek_metric_initial_data</span><span class="p">,</span> 
		<span class="n">dataset_b_frag_type</span><span class="o">=</span><span class="s2">&quot;greek_foot&quot;</span>
	<span class="p">)</span>

	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Getting keep/ignore decitala data...&quot;</span><span class="p">)</span>
	<span class="n">final_decitala_data</span> <span class="o">=</span> <span class="n">_track_keep_vals</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">decitala_cross_equivalents</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">130</span><span class="p">,</span> <span class="n">frag_type</span><span class="o">=</span><span class="s2">&quot;decitala&quot;</span><span class="p">)</span>

	<span class="c1">###############################################################################################</span>
	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tracking intra-level greek metric equivalents...&quot;</span><span class="p">)</span>
	<span class="n">greek_intra_equivalents</span> <span class="o">=</span> <span class="n">_track_rd_equivalents</span><span class="p">(</span>
		<span class="n">dataset_a</span><span class="o">=</span><span class="n">greek_metric_initial_data</span><span class="p">,</span> 
		<span class="n">dataset_b</span><span class="o">=</span><span class="n">greek_metric_initial_data</span><span class="p">,</span> 
		<span class="n">dataset_b_frag_type</span><span class="o">=</span><span class="s2">&quot;greek_foot&quot;</span>
	<span class="p">)</span>	
	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Tracking cross-corpus greek metric equivalents...&quot;</span><span class="p">)</span>
	<span class="n">greek_cross_equivalents</span> <span class="o">=</span> <span class="n">_track_rd_equivalents</span><span class="p">(</span>
		<span class="n">dataset_a</span><span class="o">=</span><span class="n">greek_intra_equivalents</span><span class="p">,</span> 
		<span class="n">dataset_b</span><span class="o">=</span><span class="n">decitala_initial_data</span><span class="p">,</span> 
		<span class="n">dataset_b_frag_type</span><span class="o">=</span><span class="s2">&quot;decitala&quot;</span>
	<span class="p">)</span>

	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Getting keep/ignore greek metric data...&quot;</span><span class="p">)</span>
	<span class="n">final_greek_data</span> <span class="o">=</span> <span class="n">_track_keep_vals</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">greek_cross_equivalents</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">26</span><span class="p">,</span> <span class="n">frag_type</span><span class="o">=</span><span class="s2">&quot;greek_foot&quot;</span><span class="p">)</span>

	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Creating the fragments tables...&quot;</span><span class="p">)</span>
	<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">db_path</span><span class="p">)</span>
	
	<span class="n">_make_table</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">final_decitala_data</span><span class="p">,</span> <span class="n">table_name</span><span class="o">=</span><span class="s2">&quot;Decitalas&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">conn</span><span class="p">)</span>
	<span class="n">_make_table</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">final_greek_data</span><span class="p">,</span> <span class="n">table_name</span><span class="o">=</span><span class="s2">&quot;Greek_Metrics&quot;</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">conn</span><span class="p">)</span>
	
	<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Done preparing ✔&quot;</span><span class="p">)</span>
	<span class="n">conn</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, Luke Poeppel.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>