

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>decitala.utils &mdash; decitala 0.14.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> decitala
          

          
          </a>

          
            
            
              <div class="version">
                0.14.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../mods/database.html">database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/fragment.html">fragment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/hash_table.html">hash_table</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/hm.html">hm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/path_finding.html">path_finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/search.html">search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/sp.html">sp</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/trees.html">trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/utils.html">utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mods/vis.html">vis</a></li>
</ul>
<p class="caption"><span class="caption-text">Rhythmic Corpora</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../datasets/decitalas.html">Desītālas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datasets/greek_metrics.html">Greek Metrics</a></li>
</ul>
<p class="caption"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usage.html">Basic Usage</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">decitala</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>decitala.utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for decitala.utils</h1><div class="highlight"><pre>
<span></span><span class="c1">####################################################################################################</span>
<span class="c1"># File:     utils.py</span>
<span class="c1"># Purpose:  Random useful functions.</span>
<span class="c1">#</span>
<span class="c1"># Author:   Luke Poeppel</span>
<span class="c1">#</span>
<span class="c1"># Location: Kent, CT 2020 / Frankfurt, DE 2020 / NYC, 2021</span>
<span class="c1">####################################################################################################</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">more_itertools</span> <span class="kn">import</span> <span class="n">consecutive_groups</span><span class="p">,</span> <span class="n">windowed</span><span class="p">,</span> <span class="n">powerset</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">converter</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">note</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">stream</span>
<span class="kn">from</span> <span class="nn">music21.meter</span> <span class="kn">import</span> <span class="n">TimeSignature</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">fragment</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">NOTE: Normally a crescent moon superscript is used. Since it serves the same function as viramas, we</span>
<span class="sd">use the same notation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">carnatic_symbols</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s2">&quot;o&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Druta&quot;</span><span class="p">},</span>
	<span class="s2">&quot;oc&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mf">0.375</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Druta-Virama&quot;</span><span class="p">},</span>
	<span class="s2">&quot;|&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laghu&quot;</span><span class="p">},</span>
	<span class="s2">&quot;|c&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Laghu-Virama&quot;</span><span class="p">},</span>
	<span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Guru&quot;</span><span class="p">},</span>
	<span class="s2">&quot;Sc&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mf">1.5</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Pluta&quot;</span><span class="p">}</span>
	<span class="c1"># [&#39;kakapadam&#39;, &#39;8X&#39;, 2.0]</span>
<span class="p">}</span>

<span class="n">greek_diacritics</span> <span class="o">=</span> <span class="p">[</span>
	<span class="p">[</span><span class="s1">&#39;breve&#39;</span><span class="p">,</span> <span class="s1">&#39;⏑&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;macron&#39;</span><span class="p">,</span> <span class="s1">&#39;––&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">multiplicative_augmentations</span> <span class="o">=</span> <span class="p">[</span>
	<span class="p">[</span><span class="s1">&#39;Tiers&#39;</span><span class="p">,</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Un quart&#39;</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Du Point&#39;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Classique&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Double&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Triple&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="p">]</span>

<span class="n">PRIMES</span> <span class="o">=</span> <span class="p">[</span>
	<span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span>
	<span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span>
	<span class="mi">29</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span>
	<span class="mi">43</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">53</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span>
	<span class="mi">61</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span>
	<span class="mi">79</span><span class="p">,</span> <span class="mi">83</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">97</span>
<span class="p">]</span>

<span class="n">VALID_DENOMINATORS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">]</span>

<span class="n">flatten</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">l</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>

<div class="viewcode-block" id="UtilsException"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.UtilsException">[docs]</a><span class="k">class</span> <span class="nc">UtilsException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
	<span class="k">pass</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># LOGGING</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="get_logger"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.get_logger">[docs]</a><span class="k">def</span> <span class="nf">get_logger</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">print_to_console</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">write_to_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A simple helper for logging.</span>

<span class="sd">	:param str name: name of the logging object to be created.</span>
<span class="sd">	:param bool print_to_console: whether to print the logs to the console.</span>
<span class="sd">	:param str write_to_file: optional filepath to save the logs to.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">logger</span><span class="o">.</span><span class="n">handlers</span><span class="p">):</span>
		<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">write_to_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
			<span class="n">file_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">FileHandler</span><span class="p">(</span><span class="n">write_to_file</span><span class="p">)</span>
			<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">file_handler</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">print_to_console</span><span class="p">:</span>
			<span class="n">stdout_handler</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
			<span class="n">logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">stdout_handler</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">logger</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># NOTATION CONVERSION</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="carnatic_string_to_ql_array"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.carnatic_string_to_ql_array">[docs]</a><span class="k">def</span> <span class="nf">carnatic_string_to_ql_array</span><span class="p">(</span><span class="n">string_</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param str string_: A string of carnatic durations separated by spaces.</span>
<span class="sd">	:return: The input string converted to a quarter length array.</span>
<span class="sd">	:rtype: numpy.array.</span>

<span class="sd">	&gt;&gt;&gt; carnatic_string_to_ql_array(&#39;oc o | | Sc S o o o&#39;)</span>
<span class="sd">	array([0.375, 0.25 , 0.5  , 0.5  , 1.5  , 1.   , 0.25 , 0.25 , 0.25 ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">split_string</span> <span class="o">=</span> <span class="n">string_</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
	<span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">split_string</span><span class="p">:</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">carnatic_symbols</span><span class="p">[</span><span class="n">token</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
				<span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">carnatic_symbols</span><span class="p">[</span><span class="n">token</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">])</span>
		<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
			<span class="k">pass</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="ql_array_to_carnatic_string"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.ql_array_to_carnatic_string">[docs]</a><span class="k">def</span> <span class="nf">ql_array_to_carnatic_string</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param ql_array: A quarter length array.</span>
<span class="sd">	:return: The quarter length array converted to carnatic notation.</span>
<span class="sd">	:rtype: str</span>

<span class="sd">	&gt;&gt;&gt; ql_array_to_carnatic_string([0.5, 0.25, 0.25, 0.375, 1.0, 1.5, 1.0, 0.5, 1.0])</span>
<span class="sd">	&#39;| o o oc S Sc S | S&#39;</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">ql</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">carnatic_symbols</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">carnatic_symbols</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">ql</span><span class="p">:</span>
				<span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
	<span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span></div>

<div class="viewcode-block" id="ql_array_to_greek_diacritics"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.ql_array_to_greek_diacritics">[docs]</a><span class="k">def</span> <span class="nf">ql_array_to_greek_diacritics</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns the input ``ql_array`` in greek prosodic notation. This notation only allows</span>
<span class="sd">	for two types of rhythmic values (long &amp; short).</span>

<span class="sd">	:param ql_array: A quarter length array.</span>
<span class="sd">	:return: The quarter length array converted to greek prosodic notation.</span>
<span class="sd">	:rtype: str</span>

<span class="sd">	&gt;&gt;&gt; ql_array_to_greek_diacritics(ql_array=[1.0, 0.5, 0.5, 1.0, 1.0, 0.5])</span>
<span class="sd">	&#39;–– ⏑ ⏑ –– –– ⏑&#39;</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">ql_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ql_array</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span>

	<span class="n">long_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">short_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">long_factor</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">long_val</span>
	<span class="n">short_factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">short_val</span>

	<span class="n">ql_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span> <span class="o">*</span> <span class="n">long_factor</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">long_val</span> <span class="k">else</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">short_factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">])</span>
	<span class="n">greek_string_lst</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">this_diacritic_name</span><span class="p">,</span> <span class="n">this_diacritic_symbol</span><span class="p">,</span> <span class="n">this_diacritic_val</span> <span class="ow">in</span> <span class="n">greek_diacritics</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">this_diacritic_val</span><span class="p">:</span>
				<span class="n">greek_string_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_diacritic_symbol</span><span class="p">)</span>

	<span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">greek_string_lst</span><span class="p">)</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># RHYTHM</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="augment"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.augment">[docs]</a><span class="k">def</span> <span class="nf">augment</span><span class="p">(</span><span class="n">ql_array</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">difference</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns an augmentation in the style of Messiaen. If difference is set to 0.0, then the</span>
<span class="sd">	augmentation is multiplicative. If factor is set to 1.0, then augmentation is additive. If</span>
<span class="sd">	factor &amp; difference are non-zero, we have a mixed augmentation.</span>

<span class="sd">	:param ql_array: A quarter length array.</span>
<span class="sd">	:param float factor: The factor for multiplicative augmentation.</span>
<span class="sd">	:param float difference: The factor for additive augmentation.</span>
<span class="sd">	:return: The fragment augmented by the given `factor` and `difference`.</span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; augment(ql_array=[1.0, 1.0, 0.5, 0.25], factor=2.0, difference=0.25)</span>
<span class="sd">	array([2.25, 2.25, 1.25, 0.75])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">this_val</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">difference</span> <span class="k">for</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">])</span></div>

<div class="viewcode-block" id="stretch_augment"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.stretch_augment">[docs]</a><span class="k">def</span> <span class="nf">stretch_augment</span><span class="p">(</span><span class="n">ql_array</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">stretch_factor</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	A special kind of rhythmic augmentation catered toward the Greek metrics. The &quot;short&quot; is</span>
<span class="sd">	kept as is and the &quot;long&quot; is modified by the given difference. The new long must still be</span>
<span class="sd">	longer than the short value.</span>

<span class="sd">	:param ql_array: A quarter length array.</span>

<span class="sd">	&gt;&gt;&gt; stretch_augment(ql_array=[1.0, 2.0], factor=0.125, stretch_factor=0.25)</span>
<span class="sd">	array([0.125, 0.5  ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ql_array</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mi">2</span>

	<span class="n">stretch_augmentation</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">breve</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">breve</span><span class="p">:</span>
			<span class="n">stretch_augmentation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">factor</span> <span class="o">*</span> <span class="n">breve</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">stretch_augmentation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_val</span> <span class="o">*</span> <span class="n">stretch_factor</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stretch_augmentation</span><span class="p">)</span></div>

<div class="viewcode-block" id="successive_ratio_array"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.successive_ratio_array">[docs]</a><span class="k">def</span> <span class="nf">successive_ratio_array</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns array defined by the ratio of successive elements. By convention,</span>
<span class="sd">	we set the first value to 1.0.</span>

<span class="sd">	:param ql_array: A quarter length array.</span>
<span class="sd">	:return: An array consisting of successive ratios of the input elements.</span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; successive_ratio_array([1.0, 1.0, 2.0, 0.5, 0.5, 0.25, 1.0])</span>
<span class="sd">	array([1.  , 1.  , 2.  , 0.25, 1.  , 0.5 , 4.  ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">ql_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">ql_array</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">ql_array</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span></div>

<div class="viewcode-block" id="successive_difference_array"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.successive_difference_array">[docs]</a><span class="k">def</span> <span class="nf">successive_difference_array</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns the first order difference of ``ql_array`` (contiguous differences).</span>

<span class="sd">	:param ql_array: A quarter length array.</span>
<span class="sd">	:return: An array consisting of successive differences of the input elements.</span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; successive_difference_array([0.25, 0.25, 0.75, 0.75, 0.5, 1.0, 1.5])</span>
<span class="sd">	array([ 0.  ,  0.  ,  0.5 ,  0.  , -0.25,  0.5 ,  0.5 ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">_remove_adjacent_equal_elements</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
	<span class="n">as_lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
	<span class="n">filtered</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">as_lst</span><span class="p">,</span> <span class="n">as_lst</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="ow">not</span> <span class="n">as_lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filtered</span><span class="p">)</span>

<div class="viewcode-block" id="dseg"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.dseg">[docs]</a><span class="k">def</span> <span class="nf">dseg</span><span class="p">(</span><span class="n">ql_array</span><span class="p">,</span> <span class="n">reduced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_str</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param bool reduced: Whether to remove equal contiguous values.</span>
<span class="sd">	:param bool as_str: Whether to make the return type a string.</span>
<span class="sd">	:return: The d-seg of the fragment, as introducted in `The Perception of Rhythm</span>
<span class="sd">			in Non-Tonal Music</span>
<span class="sd">			&lt;https://www.jstor.org/stable/745974?seq=1#metadata_info_tab_contents&gt;`_</span>
<span class="sd">			(Marvin, 1991). Maps a fragment into a sequence of relative durations.</span>
<span class="sd">	:rtype: numpy.array (or string if `as_str=True`).</span>

<span class="sd">	&gt;&gt;&gt; g3 = fragment.GeneralFragment(np.array([0.25, 0.75, 2.0, 1.0]), name=&#39;marvin-p70&#39;)</span>
<span class="sd">	&gt;&gt;&gt; g3.dseg()</span>
<span class="sd">	array([0, 1, 3, 2])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">dseg_vals</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">value_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dseg_vals</span><span class="p">)))),</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">dseg_vals</span><span class="p">))):</span>
		<span class="n">value_dict</span><span class="p">[</span><span class="n">this_val</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dseg_vals</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
				<span class="n">dseg_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">value_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

	<span class="n">dseg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dseg_vals</span><span class="p">])</span>
	<span class="k">if</span> <span class="n">reduced</span><span class="p">:</span>
		<span class="n">dseg</span> <span class="o">=</span> <span class="n">_remove_adjacent_equal_elements</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">dseg</span><span class="p">)</span>

	<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">as_str</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">dseg</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="s2">&quot;&lt;&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dseg</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span></div>

<span class="c1"># La Valeur Ajoutee</span>
<span class="k">def</span> <span class="nf">get_added_values</span><span class="p">(</span><span class="n">ql_array</span><span class="p">,</span> <span class="n">print_type</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Given a quarter length list, returns all indices and types of added values found, according to</span>
<span class="sd">	the examples dicussed in Technique de Mon Langage Musical (1944).</span>

<span class="sd">	:param ql_array: Array defining a rhythmic fragment (iterable).</span>
<span class="sd">	:param bool print_type: Whether to print the Valéur Ajoutée types, along with the locations.</span>
<span class="sd">	:return: Location of extracted added values (along with their type if ``print_type=True``)</span>
<span class="sd">	:rtype: list</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([0.25, 0.5, 0.5, 0.75, 0.25])</span>
<span class="sd">	[(0, &#39;du Note&#39;), (4, &#39;du Note&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.25, 0.5, 0.25, 1.0])</span>
<span class="sd">	[(1, &#39;du Note&#39;), (3, &#39;du Note&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.75, 0.75, 0.75, 0.25, 0.5])</span>
<span class="sd">	[(3, &#39;du Note&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.75, 0.75, 0.75, 0.75, 0.25, 0.25])</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.25, 0.5, 0.75, 1.25, 1.5])</span>
<span class="sd">	[(1, &#39;du Note&#39;), (3, &#39;du Point&#39;), (4, &#39;du Tie&#39;)]</span>

<span class="sd">	&gt;&gt;&gt; l = [1.0, 0.5, 0.25, 1.0, 0.5, 0.75, 0.5]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values(l)</span>
<span class="sd">	[(2, &#39;du Note&#39;), (5, &#39;du Point&#39;)]</span>

<span class="sd">	?????</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.5, 0.75, 1.25, 0.75])</span>
<span class="sd">	[(2, &#39;du Point&#39;), (3, &#39;du Tie&#39;)]</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([1.0, 0.25, 0.5], print_type = False)</span>
<span class="sd">	[1]</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([0.25, 0.25, 0.75, 2.0])</span>
<span class="sd">	[(2, &#39;du Point&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.25, 0.75, 0.25, 0.5])</span>
<span class="sd">	[(1, &#39;du Note&#39;), (2, &#39;du Point&#39;), (3, &#39;du Note&#39;)]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;List must be of length 3 or greater.&#39;</span><span class="p">)</span>

	<span class="n">addedVals</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">if</span> <span class="n">ql_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.25</span> <span class="ow">and</span> <span class="n">ql_array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.25</span><span class="p">:</span>
		<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">ql_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.25</span> <span class="ow">and</span> <span class="n">ql_array</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.25</span><span class="p">:</span>
		<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">ql_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.75</span> <span class="ow">and</span> <span class="n">ql_array</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>

	<span class="k">for</span> <span class="n">currIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">prevVal</span> <span class="o">=</span> <span class="n">ql_array</span><span class="p">[</span><span class="n">currIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
		<span class="n">currVal</span> <span class="o">=</span> <span class="n">ql_array</span><span class="p">[</span><span class="n">currIndex</span><span class="p">]</span>
		<span class="n">nextVal</span> <span class="o">=</span> <span class="n">ql_array</span><span class="p">[</span><span class="n">currIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

		<span class="n">x</span> <span class="o">=</span> <span class="n">currVal</span> <span class="o">-</span> <span class="mf">0.25</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
			<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Tie&#39;</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">currVal</span> <span class="o">==</span> <span class="mf">0.25</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">prevVal</span> <span class="o">!=</span> <span class="n">currVal</span> <span class="o">!=</span> <span class="n">nextVal</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">prevVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nextVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
				<span class="k">elif</span> <span class="n">prevVal</span> <span class="o">%</span> <span class="mf">0.75</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
				<span class="k">elif</span> <span class="n">nextVal</span> <span class="o">%</span> <span class="mf">0.75</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">currVal</span> <span class="o">==</span> <span class="mf">0.75</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">prevVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nextVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">prevVal</span> <span class="o">&lt;</span> <span class="n">currVal</span> <span class="ow">and</span> <span class="n">nextVal</span> <span class="o">&gt;</span> <span class="n">currVal</span><span class="p">:</span>
				<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">prevVal</span> <span class="o">==</span> <span class="mf">0.25</span><span class="p">:</span>
				<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">addedVals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">None</span>

	<span class="k">if</span> <span class="n">print_type</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">addedVals</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">addedVals</span>

<span class="k">def</span> <span class="nf">removeAddedValuesFromList</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
	<span class="n">added_val_indices</span> <span class="o">=</span> <span class="n">get_added_values</span><span class="p">(</span><span class="n">ql_lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">print_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">added_val_indices</span><span class="p">:</span>
		<span class="k">del</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
	<span class="k">return</span>

<div class="viewcode-block" id="non_retrogradable_measures"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.non_retrogradable_measures">[docs]</a><span class="k">def</span> <span class="nf">non_retrogradable_measures</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">part_num</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function for retrieving all non-retrogradable measures in a given filepath and part number.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">converted</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">converted</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part_num</span><span class="p">]</span>
	<span class="n">non_retrogradable_measures</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_measure</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">Measure</span><span class="p">):</span>
		<span class="n">ql_array</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">this_note</span> <span class="ow">in</span> <span class="n">this_measure</span><span class="o">.</span><span class="n">flat</span><span class="o">.</span><span class="n">stripTies</span><span class="p">()</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">note</span><span class="o">.</span><span class="n">Note</span><span class="p">):</span>
			<span class="n">ql_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_note</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">)</span>

		<span class="k">if</span> <span class="n">ql_array</span> <span class="o">==</span> <span class="n">ql_array</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
			<span class="n">non_retrogradable_measures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_measure</span><span class="o">.</span><span class="n">number</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">non_retrogradable_measures</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># SUBDIVISION</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="find_clusters"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.find_clusters">[docs]</a><span class="k">def</span> <span class="nf">find_clusters</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">data_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Finds the regions with consecutive equal elements.</span>

<span class="sd">	:param iterable input_: Either a list/array (representing</span>
<span class="sd">							:obj:`~decitala.fragment.GeneralFragment.ql_array`) or data from</span>
<span class="sd">							:obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:param bool data_mode: whether the input data is data from</span>
<span class="sd">							:obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:return: a list of cluster indices; if not in data mode, regions with equal quarter length values;</span>
<span class="sd">			if ``data_mode=True``, then regions where the quarter lengths and pitch content are equal.</span>

<span class="sd">	&gt;&gt;&gt; varied_ragavardhana = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; clusters = find_clusters(varied_ragavardhana)</span>
<span class="sd">	&gt;&gt;&gt; clusters</span>
<span class="sd">	[[0, 2], [4, 5], [7, 9]]</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana[clusters[0][0]:clusters[0][1]+1]</span>
<span class="sd">	array([1., 1., 1.])</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana[clusters[1][0]:clusters[1][1]+1]</span>
<span class="sd">	array([0.75, 0.75])</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana[clusters[2][0]:clusters[2][1]+1]</span>
<span class="sd">	array([0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; # We can also find clusters of pitch and rhythmic information for data from get_object_indices.</span>
<span class="sd">	&gt;&gt;&gt; from music21 import note, chord</span>
<span class="sd">	&gt;&gt;&gt; example_data = [</span>
<span class="sd">	...		(note.Note(&quot;F#&quot;), (6.5, 6.75)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (6.75, 7.0)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.0, 7.25)),</span>
<span class="sd">	...     (note.Note(&quot;C#&quot;), (7.25, 7.5)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.5, 7.75)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.75, 8.0)),</span>
<span class="sd">	...     (note.Note(&quot;A-&quot;), (8.0, 8.125)),</span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; find_clusters(example_data, data_mode=True)</span>
<span class="sd">	[[1, 2], [4, 5]]</span>
<span class="sd">	&gt;&gt;&gt; example_data2 = [</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.0, 0.125)),</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.125, 0.25)),</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.25, 0.375)),</span>
<span class="sd">	... 	(chord.Chord([&quot;E-3&quot;, &quot;D4&quot;], quarterLength=0.125), (0.375, 0.5)),</span>
<span class="sd">	... 	(chord.Chord([&quot;A2&quot;, &quot;A-3&quot;], quarterLength=0.25), (0.5, 0.75)),</span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; find_clusters(example_data2, data_mode=True)</span>
<span class="sd">	[[0, 2]]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">data_mode</span><span class="p">):</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">regions_property</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">midi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pitches</span><span class="p">])</span>  <span class="c1"># noqa: E501</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">)),</span> <span class="n">regions_property</span><span class="p">)]</span>

	<span class="n">cluster_index_ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">this_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># noqa: E501</span>

	<span class="k">return</span> <span class="n">cluster_index_ranges</span></div>

<span class="k">def</span> <span class="nf">_compliment_of_index_ranges</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">clusters</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	TODO: if the compliment range has only one val, it should just be one val, not two</span>
<span class="sd">	(otherwise can&#39;t distinguish).</span>

<span class="sd">	&gt;&gt;&gt; varied_ragavardhana = np.array([1, 1, 1, 0.5, 0.75, 0.5])</span>
<span class="sd">	&gt;&gt;&gt; _compliment_of_index_ranges(varied_ragavardhana, [find_clusters(varied_ragavardhana)[0]])</span>
<span class="sd">	[[3, 5]]</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana_2 = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; _compliment_of_index_ranges(varied_ragavardhana_2, find_clusters(varied_ragavardhana_2))</span>
<span class="sd">	[[3], [6]]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">flattened_cluster_ranges</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
		<span class="n">index_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">this_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">flattened_cluster_ranges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">index_range</span><span class="p">)</span>

	<span class="n">total_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">total_range</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">flattened_cluster_ranges</span><span class="p">)))</span>

	<span class="n">compliments</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">consecutive_groups</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
		<span class="n">elem_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">compliments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem_list</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">compliments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">elem_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">elem_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

	<span class="k">return</span> <span class="n">compliments</span>

<span class="k">def</span> <span class="nf">_make_one_superdivision</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">clusters</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana_2 = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; c = find_clusters(varied_ragavardhana_2)</span>
<span class="sd">	&gt;&gt;&gt; # one combination of the clusters is [[0, 2], [7, 9]]</span>
<span class="sd">	&gt;&gt;&gt; _make_one_superdivision(varied_ragavardhana_2, [[0, 2], [7, 9]])</span>
<span class="sd">	array([3.  , 0.5 , 0.75, 0.75, 0.5 , 0.75])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">superdivision</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
	<span class="n">compliment_ranges</span> <span class="o">=</span> <span class="n">_compliment_of_index_ranges</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">compliment_ranges</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">superdivision</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">superdivision</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

	<span class="k">for</span> <span class="n">this_cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
		<span class="n">region</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">this_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">this_cluster</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
		<span class="n">summed</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
		<span class="n">superdivision</span><span class="p">[</span><span class="n">this_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">summed</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">superdivision</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>

<div class="viewcode-block" id="find_possible_superdivisions"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.find_possible_superdivisions">[docs]</a><span class="k">def</span> <span class="nf">find_possible_superdivisions</span><span class="p">(</span><span class="n">ql_array</span><span class="p">,</span> <span class="n">include_self</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	There is a more general approach to the subdivision problem, but we note that Messiaen&#39;s</span>
<span class="sd">	subdivision of tala components tends to be even.</span>

<span class="sd">	&gt;&gt;&gt; long_fragment = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; for x in find_possible_superdivisions(long_fragment):</span>
<span class="sd">	...     print(x)</span>
<span class="sd">	[1.   1.   1.   0.5  0.75 0.75 0.5  0.25 0.25 0.25]</span>
<span class="sd">	[3.   0.5  0.75 0.75 0.5  0.25 0.25 0.25]</span>
<span class="sd">	[1.   1.   1.   0.5  1.5  0.5  0.25 0.25 0.25]</span>
<span class="sd">	[1.   1.   1.   0.5  0.75 0.75 0.5  0.75]</span>
<span class="sd">	[3.   0.5  1.5  0.5  0.25 0.25 0.25]</span>
<span class="sd">	[3.   0.5  0.75 0.75 0.5  0.75]</span>
<span class="sd">	[1.   1.   1.   0.5  1.5  0.5  0.75]</span>
<span class="sd">	[3.   0.5  1.5  0.5  0.75]</span>

<span class="sd">	&gt;&gt;&gt; varied_ragavardhana = np.array([1, 1, 1, 0.5, 0.75, 0.5])</span>
<span class="sd">	&gt;&gt;&gt; for x in find_possible_superdivisions(varied_ragavardhana, include_self=False):</span>
<span class="sd">	...     print(x)</span>
<span class="sd">	[3.   0.5  0.75 0.5 ]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">include_self</span><span class="p">:</span>
		<span class="n">possible_super_divisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">possible_super_divisions</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">clusters</span> <span class="o">=</span> <span class="n">find_clusters</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">possible_combinations</span> <span class="o">=</span> <span class="n">power_list</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">this_combination</span> <span class="ow">in</span> <span class="n">possible_combinations</span><span class="p">:</span>
		<span class="n">superdivision</span> <span class="o">=</span> <span class="n">_make_one_superdivision</span><span class="p">(</span><span class="n">ql_array</span><span class="p">,</span> <span class="n">this_combination</span><span class="p">)</span>
		<span class="n">possible_super_divisions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">superdivision</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">possible_super_divisions</span></div>

<div class="viewcode-block" id="net_ql_array"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.net_ql_array">[docs]</a><span class="k">def</span> <span class="nf">net_ql_array</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">part_num</span><span class="p">,</span> <span class="n">include_rests</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore_grace_notes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function for retrieving all quarter lengths from a part number in a filepath.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">converted</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
	<span class="n">stripped</span> <span class="o">=</span> <span class="n">converted</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part_num</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="o">.</span><span class="n">stripTies</span><span class="p">()</span>
	<span class="n">qls</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">include_rests</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">stripped</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">notes</span><span class="p">:</span>
			<span class="n">qls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">stripped</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">notesAndRests</span><span class="p">:</span>
			<span class="n">qls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">ignore_grace_notes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
		<span class="n">qls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">qls</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qls</span><span class="p">)</span></div>

<div class="viewcode-block" id="transform_to_time_scale"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.transform_to_time_scale">[docs]</a><span class="k">def</span> <span class="nf">transform_to_time_scale</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Transforms a quarter length array to time-scale (binary) notation.</span>

<span class="sd">	:param ql_array: A quarter length array.</span>

<span class="sd">	&gt;&gt;&gt; udikshana = fragment.Decitala(&quot;Udikshana&quot;)</span>
<span class="sd">	&gt;&gt;&gt; udikshana.ql_array()</span>
<span class="sd">	array([0.5, 0.5, 1. ])</span>
<span class="sd">	&gt;&gt;&gt; transform_to_time_scale(ql_array=udikshana.ql_array())</span>
<span class="sd">	array([1, 1, 1, 0])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">total_durations</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">shortest_value</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="n">shortest_value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ql_array</span><span class="p">)):</span>
		<span class="n">total_durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span> <span class="o">/</span> <span class="n">shortest_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">])</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
		<span class="c1"># This upper bound is arbitrary; something between 4 and 10 should suffice.</span>
		<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="p">(</span><span class="n">shortest_value</span> <span class="o">/</span> <span class="n">i</span><span class="p">))</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(),</span> <span class="n">ql_array</span><span class="p">)):</span>
				<span class="n">total_durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">shortest_value</span> <span class="o">/</span> <span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">])</span>
				<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_durations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Something is wrong with the input quarter lengths!&quot;</span><span class="p">)</span>

	<span class="n">result_out</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_elem</span> <span class="ow">in</span> <span class="n">total_durations</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">this_elem</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
			<span class="n">result_out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">result_out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">result_out</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">this_elem</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result_out</span><span class="p">)</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># WINDOWING / PARTITIONING</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="roll_window"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.roll_window">[docs]</a><span class="k">def</span> <span class="nf">roll_window</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Takes in a list and returns a numpy vstack holding rolling windows of length ``window_size``.</span>

<span class="sd">	:param array: a list, tuple, numpy array, etc.</span>
<span class="sd">	:param int window_size: size of the window</span>
<span class="sd">	:param lambda fn: a function evaluating a bool; will only iterate over elements satifying the</span>
<span class="sd">						function.</span>
<span class="sd">	:return: A rolling windows of array, each of length `window_size`.</span>
<span class="sd">	:rtype: numpy.vstack</span>

<span class="sd">	&gt;&gt;&gt; composers = np.array([&#39;Mozart&#39;, &#39;Monteverdi&#39;, &#39;Messiaen&#39;, &#39;Mahler&#39;, &#39;MacDowell&#39;, &#39;Massenet&#39;])</span>
<span class="sd">	&gt;&gt;&gt; for window in roll_window(array=composers, window_size=3):</span>
<span class="sd">	...     print(window)</span>
<span class="sd">	(&#39;Mozart&#39;, &#39;Monteverdi&#39;, &#39;Messiaen&#39;)</span>
<span class="sd">	(&#39;Monteverdi&#39;, &#39;Messiaen&#39;, &#39;Mahler&#39;)</span>
<span class="sd">	(&#39;Messiaen&#39;, &#39;Mahler&#39;, &#39;MacDowell&#39;)</span>
<span class="sd">	(&#39;Mahler&#39;, &#39;MacDowell&#39;, &#39;Massenet&#39;)</span>
<span class="sd">	&gt;&gt;&gt; # This function also allows the use of a function input for filtering.</span>
<span class="sd">	&gt;&gt;&gt; # Say we wanted to iterate over the elements of the following collection that have</span>
<span class="sd">	&gt;&gt;&gt; # 1s in the set.</span>
<span class="sd">	&gt;&gt;&gt; cseg_data = [[0, {1, -1}], [4, {1}], [2, {-1}], [5, {1}], [5, {1}], [1, {1, -1}]]</span>
<span class="sd">	&gt;&gt;&gt; fn = lambda x: 1 in x[1]</span>
<span class="sd">	&gt;&gt;&gt; for this_frame in roll_window(cseg_data, 3, fn):</span>
<span class="sd">	... 	print(this_frame)</span>
<span class="sd">	([0, {1, -1}], [4, {1}], [5, {1}])</span>
<span class="sd">	([4, {1}], [5, {1}], [5, {1}])</span>
<span class="sd">	([5, {1}], [5, {1}], [1, {1, -1}])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">array</span> <span class="k">if</span> <span class="n">fn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">]</span>
	<span class="n">windows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">windowed</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">windows</span></div>

<div class="viewcode-block" id="power_list"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.power_list">[docs]</a><span class="k">def</span> <span class="nf">power_list</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param data: an iterable</span>
<span class="sd">	:return: power set of the data as a list (excluding the empty list).</span>
<span class="sd">	:rtype: list</span>

<span class="sd">	&gt;&gt;&gt; l = [1, 2, 3]</span>
<span class="sd">	&gt;&gt;&gt; power_list(l)</span>
<span class="sd">	[(1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]</span>

<span class="sd">	&gt;&gt;&gt; for x in power_list([(0.0, 2.0), (4.0, 5.5), (6.0, 7.25)]):</span>
<span class="sd">	...     print(x)</span>
<span class="sd">	((0.0, 2.0),)</span>
<span class="sd">	((4.0, 5.5),)</span>
<span class="sd">	((6.0, 7.25),)</span>
<span class="sd">	((0.0, 2.0), (4.0, 5.5))</span>
<span class="sd">	((0.0, 2.0), (6.0, 7.25))</span>
<span class="sd">	((4.0, 5.5), (6.0, 7.25))</span>
<span class="sd">	((0.0, 2.0), (4.0, 5.5), (6.0, 7.25))</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
	<span class="n">power_list</span> <span class="o">=</span> <span class="n">powerset</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">power_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># SCORE HELPERS</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="get_object_indices"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.get_object_indices">[docs]</a><span class="k">def</span> <span class="nf">get_object_indices</span><span class="p">(</span>
		<span class="n">filepath</span><span class="p">,</span>
		<span class="n">part_num</span><span class="p">,</span>
		<span class="n">measure_divider_mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
		<span class="n">ignore_grace</span><span class="o">=</span><span class="kc">False</span>
	<span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns data of the form [(object, (start, end)), ...] for a given file path and part number.</span>
<span class="sd">	(Supports rests and grace notes.)</span>

<span class="sd">	:param str filepath: Path to file to be analyzed.</span>
<span class="sd">	:param int part_num: Part number to be analyzed.</span>
<span class="sd">	:param str measure_divider_mode: Tool used for dividing the data into measures. If</span>
<span class="sd">									``measure_divider_mode=&quot;str&quot;``, the data is returned with</span>
<span class="sd">									``&quot;B&quot;`` used as the measure marker. If instead</span>
<span class="sd">									``measure_divider_mode=&quot;list&quot;``, the data is returned</span>
<span class="sd">									partitioned by measure. The default is ``None``, so no</span>
<span class="sd">									measure divisions are present.</span>
<span class="sd">	:param bool ignore_grace: Whether to ignore grace notes in the output. ``False`` by default.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">score</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
	<span class="n">part</span> <span class="o">=</span> <span class="n">score</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part_num</span><span class="p">]</span>
	<span class="n">stripped</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">stripTies</span><span class="p">(</span><span class="n">retainContainers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">measure_divider_mode</span><span class="p">:</span>
		<span class="n">data_out</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">this_obj</span> <span class="ow">in</span> <span class="n">stripped</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span><span class="o">.</span><span class="n">stream</span><span class="p">()</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">notesAndRests</span><span class="p">:</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span>
			<span class="n">stop</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">quarterLength</span>
			<span class="n">data_out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">this_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>
		<span class="k">if</span> <span class="n">ignore_grace</span><span class="p">:</span>
			<span class="n">data_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data_out</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

		<span class="k">return</span> <span class="n">data_out</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">ms</span> <span class="o">=</span> <span class="n">stripped</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">Measure</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">measure_divider_mode</span> <span class="o">==</span> <span class="s2">&quot;list&quot;</span><span class="p">:</span>
			<span class="n">data_out</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">this_measure</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span>
				<span class="n">measure_objects</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">this_obj</span> <span class="ow">in</span> <span class="n">this_measure</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span><span class="o">.</span><span class="n">stream</span><span class="p">()</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">notesAndRests</span><span class="p">:</span>
					<span class="n">start</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span>
					<span class="n">stop</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">quarterLength</span>
					<span class="k">if</span> <span class="n">ignore_grace</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
							<span class="k">continue</span>
					<span class="n">measure_objects</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">this_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>
				<span class="n">data_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">measure_objects</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">measure_divider_mode</span> <span class="o">==</span> <span class="s2">&quot;str&quot;</span><span class="p">:</span>
			<span class="n">data_out</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="k">for</span> <span class="n">this_measure</span> <span class="ow">in</span> <span class="n">ms</span><span class="p">:</span>
				<span class="n">measure_objs</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="k">for</span> <span class="n">this_obj</span> <span class="ow">in</span> <span class="n">this_measure</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span><span class="o">.</span><span class="n">stream</span><span class="p">()</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">notesAndRests</span><span class="p">:</span>
					<span class="n">start</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span>
					<span class="n">stop</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">quarterLength</span>
					<span class="k">if</span> <span class="n">ignore_grace</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
							<span class="k">continue</span>

					<span class="n">measure_objs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">this_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>
				<span class="n">data_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">measure_objs</span><span class="p">)</span>
				<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">this_measure</span><span class="o">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">ms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">number</span><span class="p">):</span>
					<span class="n">data_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Only allowed modes are `str` and `list`.&quot;</span><span class="p">)</span>

		<span class="k">return</span> <span class="n">data_out</span></div>

<div class="viewcode-block" id="phrase_divider"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.phrase_divider">[docs]</a><span class="k">def</span> <span class="nf">phrase_divider</span><span class="p">(</span>
		<span class="n">filepath</span><span class="p">,</span>
		<span class="n">part_num</span>
	<span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	This is an oversimplified but useful tool for phrase analysis (particularly for the birdsongs).</span>
<span class="sd">	It returns the same output as :obj:`decitala.utils.get_object_indices` but divides the output</span>
<span class="sd">	by &quot;phrases,&quot; **only** as defined by the appearance of rests and fermatas. Ignores all dividers.</span>

<span class="sd">	:param str filepath: Path to file to be analyzed.</span>
<span class="sd">	:param int part_num: Part number to be analyzed.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">all_objects</span> <span class="o">=</span> <span class="n">get_object_indices</span><span class="p">(</span>
		<span class="n">filepath</span><span class="p">,</span>
		<span class="n">part_num</span>
	<span class="p">)</span>
	<span class="n">all_phrases</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">phrase</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="n">all_objects</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isRest</span><span class="p">):</span>
		<span class="n">all_phrases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">phrase</span><span class="p">))</span>

	<span class="n">desired_phrases</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">phrase</span> <span class="ow">in</span> <span class="n">all_phrases</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">phrase</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isRest</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">desired_phrases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>

	<span class="k">return</span> <span class="n">desired_phrases</span></div>

<div class="viewcode-block" id="reframe_ts"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.reframe_ts">[docs]</a><span class="k">def</span> <span class="nf">reframe_ts</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">new_denominator</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function for reducing a `music21.meter.TimeSignature` object (lowest denominator of 1) to</span>
<span class="sd">	a given denominiator.</span>

<span class="sd">	:param ts: A music21.meter.TimeSignature object.</span>
<span class="sd">	:return: A new time signature that is fully reduced by removing all possible powers of 2.</span>
<span class="sd">	:rtype: music21.meter.TimeSignature</span>

<span class="sd">	&gt;&gt;&gt; from music21.meter import TimeSignature</span>
<span class="sd">	&gt;&gt;&gt; reframe_ts(TimeSignature(&quot;4/16&quot;))</span>
<span class="sd">	&lt;music21.meter.TimeSignature 1/4&gt;</span>
<span class="sd">	&gt;&gt;&gt; reframe_ts(TimeSignature(&quot;4/4&quot;), new_denominator=2)</span>
<span class="sd">	&lt;music21.meter.TimeSignature 2/2&gt;</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">numerator</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">numerator</span>
	<span class="n">denominator</span> <span class="o">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">denominator</span>
	<span class="k">if</span> <span class="n">new_denominator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
		<span class="n">new_denominator</span> <span class="o">=</span> <span class="n">VALID_DENOMINATORS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">assert</span> <span class="n">new_denominator</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">VALID_DENOMINATORS</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">new_denominator</span> <span class="o">&lt;=</span> <span class="n">ts</span><span class="o">.</span><span class="n">numerator</span><span class="p">:</span>
		<span class="k">while</span> <span class="n">numerator</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">denominator</span> <span class="o">&gt;</span> <span class="n">new_denominator</span><span class="p">:</span>
			<span class="n">numerator</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="mi">2</span>
			<span class="n">denominator</span> <span class="o">=</span> <span class="n">denominator</span> <span class="o">/</span> <span class="mi">2</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">while</span> <span class="n">denominator</span> <span class="o">&lt;</span> <span class="n">new_denominator</span><span class="p">:</span>
			<span class="n">numerator</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">*</span> <span class="mi">2</span>
			<span class="n">denominator</span> <span class="o">=</span> <span class="n">denominator</span> <span class="o">*</span> <span class="mi">2</span>

	<span class="n">reduced_ts_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">numerator</span><span class="p">)</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">denominator</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
	<span class="k">return</span> <span class="n">TimeSignature</span><span class="p">(</span><span class="n">reduced_ts_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="rolling_SRR"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.rolling_SRR">[docs]</a><span class="k">def</span> <span class="nf">rolling_SRR</span><span class="p">(</span>
		<span class="n">filepath</span><span class="p">,</span>
		<span class="n">part_num</span><span class="p">,</span>
		<span class="n">window_size</span><span class="p">,</span>
		<span class="n">ignore_tuplets</span><span class="o">=</span><span class="kc">True</span>
	<span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Given a filepath, part number, and window size, extracts all notes/chords in the work and,</span>
<span class="sd">	on a rolling window, calculates the successive ratio representation (SRR) of each window.</span>
<span class="sd">	Returning the results as a list.</span>

<span class="sd">	:param str filepath: Path to file to be analyzed.</span>
<span class="sd">	:param int part_num: Part number to be analyzed.</span>
<span class="sd">	:param int window_size: Window size used in the calculations.</span>
<span class="sd">	:param bool ignore_tuplets: Whether to ignore tuplets in the output. The use of tuplets will</span>
<span class="sd">								add some erroneous ratios to the data. Default is ``True``.</span>
<span class="sd">	:return: List holding successive ratio representations of each window on a rolling window of</span>
<span class="sd">			size ``window_size``.</span>
<span class="sd">	:rtype: list</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">objects</span> <span class="o">=</span> <span class="n">get_object_indices</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">part_num</span><span class="p">,</span> <span class="n">ignore_grace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

	<span class="n">objects_without_rests_pre</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">grouped</span> <span class="o">=</span> <span class="n">groupby</span><span class="p">(</span><span class="n">objects</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isRest</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grouped</span><span class="p">:</span>
		<span class="n">objects_without_rests_pre</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>

	<span class="n">objects_without_rests</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">grouping</span> <span class="ow">in</span> <span class="n">objects_without_rests_pre</span><span class="p">:</span>
		<span class="n">first_elem</span> <span class="o">=</span> <span class="n">grouping</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">first_elem</span><span class="o">.</span><span class="n">isRest</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">objects_without_rests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">grouping</span><span class="p">))</span>

	<span class="n">all_windows</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_grouping</span> <span class="ow">in</span> <span class="n">objects_without_rests</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_grouping</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">window_size</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">all_windows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roll_window</span><span class="p">(</span><span class="n">this_grouping</span><span class="p">,</span> <span class="n">window_size</span><span class="p">))</span>

	<span class="n">all_windows</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">all_windows</span><span class="p">)</span>

	<span class="n">all_windows_ql</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">window</span> <span class="ow">in</span> <span class="n">all_windows</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">ignore_tuplets</span><span class="p">:</span>
			<span class="c1"># Ignore ratios of complex tuplets (not giving proper quarter lengths).</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">duration</span><span class="o">.</span><span class="n">tuplets</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">window</span><span class="p">):</span>
				<span class="k">continue</span>
		<span class="n">qls</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">quarterLength</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">window</span><span class="p">]</span>
		<span class="n">all_windows_ql</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qls</span><span class="p">)</span>

	<span class="n">SRRs</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">successive_ratio_array</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">all_windows_ql</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">SRRs</span></div>

<div class="viewcode-block" id="contiguous_summation"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.contiguous_summation">[docs]</a><span class="k">def</span> <span class="nf">contiguous_summation</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Given some ``data`` from :obj:`~decitala.utils.get_object_indices`, finds every location</span>
<span class="sd">	where the pitch and rhythmic material are contiguously equal and sums these regions.</span>

<span class="sd">	&gt;&gt;&gt; from music21 import note, chord</span>
<span class="sd">	&gt;&gt;&gt; example_data = [</span>
<span class="sd">	...		(note.Note(&quot;F#&quot;), (6.5, 6.75)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (6.75, 7.0)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.0, 7.25)),</span>
<span class="sd">	...     (note.Note(&quot;C#&quot;), (7.25, 7.5)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.5, 7.75)),</span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.75, 8.0)),</span>
<span class="sd">	...     (note.Note(&quot;A-&quot;), (8.0, 8.125)),</span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; for this_object in contiguous_summation(example_data):</span>
<span class="sd">	...     print(this_object)</span>
<span class="sd">	(&lt;music21.note.Note F#&gt;, (6.5, 6.75))</span>
<span class="sd">	(&lt;music21.note.Note G&gt;, (6.75, 7.25))</span>
<span class="sd">	(&lt;music21.note.Note C#&gt;, (7.25, 7.5))</span>
<span class="sd">	(&lt;music21.note.Note G&gt;, (7.5, 8.0))</span>
<span class="sd">	(&lt;music21.note.Note A-&gt;, (8.0, 8.125))</span>
<span class="sd">	&gt;&gt;&gt; # Also works with chords.</span>
<span class="sd">	&gt;&gt;&gt; example_data2 = [</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.0, 0.125)),</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.125, 0.25)),</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.25, 0.375)),</span>
<span class="sd">	... 	(chord.Chord([&quot;E-3&quot;, &quot;D4&quot;], quarterLength=0.125), (0.375, 0.5)),</span>
<span class="sd">	... 	(chord.Chord([&quot;A2&quot;, &quot;A-3&quot;], quarterLength=0.25), (0.5, 0.75)),</span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; sum_search = contiguous_summation(example_data2)</span>
<span class="sd">	&gt;&gt;&gt; for this_object in sum_search:</span>
<span class="sd">	...     print(this_object)</span>
<span class="sd">	(&lt;music21.chord.Chord F#2 F3&gt;, (0.0, 0.375))</span>
<span class="sd">	(&lt;music21.chord.Chord E-3 D4&gt;, (0.375, 0.5))</span>
<span class="sd">	(&lt;music21.chord.Chord A2 A-3&gt;, (0.5, 0.75))</span>
<span class="sd">	&gt;&gt;&gt; # The quarter lengths of the objects change according to the new summation.</span>
<span class="sd">	&gt;&gt;&gt; for this_object in sum_search:</span>
<span class="sd">	... 	print(this_object[0].quarterLength)</span>
<span class="sd">	0.375</span>
<span class="sd">	0.125</span>
<span class="sd">	0.25</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Rest&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot perform contiguous summation on a region with rests.&quot;</span><span class="p">)</span>

	<span class="n">regions_property</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">midi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pitches</span><span class="p">])</span>  <span class="c1"># noqa: E501</span>
	<span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)),</span> <span class="n">regions_property</span><span class="p">)]</span>

	<span class="n">cluster_index_ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">this_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># noqa: E501</span>
	<span class="n">compliment_ranges</span> <span class="o">=</span> <span class="n">_compliment_of_index_ranges</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cluster_index_ranges</span><span class="p">)</span>

	<span class="n">new_objects</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">this_index_range</span> <span class="ow">in</span> <span class="n">cluster_index_ranges</span><span class="p">:</span>
		<span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">this_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">start_offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">stop_offset</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">stop</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

		<span class="n">pitch_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">summed_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">pitch_data</span><span class="p">,</span> <span class="p">(</span><span class="n">start_offset</span><span class="p">,</span> <span class="n">stop_offset</span><span class="p">))</span>

		<span class="n">new_objects</span><span class="p">[</span><span class="n">this_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">summed_data</span>

	<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">compliment_ranges</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">new_objects</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">new_objects</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

	<span class="n">new_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_objects</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

	<span class="k">for</span> <span class="n">this_data</span> <span class="ow">in</span> <span class="n">new_objects</span><span class="p">:</span>
		<span class="n">new_ql</span> <span class="o">=</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">this_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">quarterLength</span> <span class="o">=</span> <span class="n">new_ql</span>

	<span class="k">return</span> <span class="n">new_objects</span></div>

<div class="viewcode-block" id="filter_single_anga_class_fragments"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.filter_single_anga_class_fragments">[docs]</a><span class="k">def</span> <span class="nf">filter_single_anga_class_fragments</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list data: data from :obj:`~decitala.trees.rolling_search`.</span>
<span class="sd">	:return: data from the input with all single-anga-class talas removed. For information on anga-class, see:</span>
<span class="sd">			:obj:`~decitala.fragment.Decitala.num_anga_classes`.</span>
<span class="sd">	:rtype: list</span>

<span class="sd">	&gt;&gt;&gt; from decitala.fragment import GreekFoot</span>
<span class="sd">	&gt;&gt;&gt; data = [</span>
<span class="sd">	... {&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.0, 0.5), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)]},  # noqa: E501</span>
<span class="sd">	... {&#39;fragment&#39;: GreekFoot(&quot;Trochee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,)]},</span>
<span class="sd">	... {&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.0625), &#39;onset_range&#39;: (0.5, 0.75), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(78,), (85,)]},</span>
<span class="sd">	... {&#39;fragment&#39;: GreekFoot(&quot;Iamb&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.625, 1.0), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(85,), (93,)]},</span>
<span class="sd">	... {&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.75, 1.25), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(93,), (91,)]}</span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; filtered = filter_single_anga_class_fragments(data)</span>
<span class="sd">	&gt;&gt;&gt; for x in filtered:</span>
<span class="sd">	... 	print(x)</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Trochee&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,)]}</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Iamb&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.625, 1.0), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(85,), (93,)]}</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">num_anga_classes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span></div>

<div class="viewcode-block" id="filter_sub_fragments"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.filter_sub_fragments">[docs]</a><span class="k">def</span> <span class="nf">filter_sub_fragments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">filter_in_retrograde</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list data: data from :obj:`~decitala.trees.rolling_search`.</span>
<span class="sd">	:return: data from the input with all sub-talas removed; that is, talas that sit inside of another.</span>
<span class="sd">	:rtype: list</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">just_fragments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]))</span>

	<span class="k">def</span> <span class="nf">_check_all</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
		<span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">for</span> <span class="n">this_fragment</span> <span class="ow">in</span> <span class="n">just_fragments</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">this_fragment</span><span class="o">.</span><span class="n">ql_array</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">ql_array</span><span class="p">()):</span>
				<span class="k">pass</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_sub_fragment</span><span class="p">(</span><span class="n">this_fragment</span><span class="p">,</span> <span class="n">filter_in_retrograde</span><span class="p">):</span>
					<span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">return</span> <span class="n">check</span>

	<span class="n">filtered_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">just_fragments</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">_check_all</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">filtered_names</span><span class="p">]</span></div>

<div class="viewcode-block" id="measure_by_measure_time_signatures"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.measure_by_measure_time_signatures">[docs]</a><span class="k">def</span> <span class="nf">measure_by_measure_time_signatures</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns list of meter.TimeSignature objects from music21 for each measure of an input</span>
<span class="sd">	stream.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">converted</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">converted</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">ts</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">this_measure</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">getElementsByClass</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">Measure</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">this_obj</span> <span class="ow">in</span> <span class="n">this_measure</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span><span class="o">.</span><span class="n">iter</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">this_obj</span><span class="p">)</span> <span class="o">==</span> <span class="n">TimeSignature</span><span class="p">:</span>
				<span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_obj</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
			<span class="k">pass</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">ts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">return</span> <span class="n">ts</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># MATH HELPERS</span>
<span class="c1">####################################################################################################</span>
<span class="k">def</span> <span class="nf">cauchy_schwartz</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Tests the Cauchy-Schwartz inequality on two vectors. Namely, if the absolute value of</span>
<span class="sd">	the dot product of the two vectors is less than the product of the norms, the vectors are</span>
<span class="sd">	linearly independant (and the function returns True); if they are equal, they are dependant</span>
<span class="sd">	(and the function returns False).</span>

<span class="sd">	Linear Independence:</span>
<span class="sd">	&gt;&gt;&gt; li_vec1 = np.array([0.375, 1.0, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; li_vec2 = np.array([1.0, 0.0, 0.5])</span>
<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(li_vec1, li_vec2)</span>
<span class="sd">	True</span>

<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(np.array([0.75, 0.5]), np.array([1.5, 1.0]))</span>
<span class="sd">	False</span>

<span class="sd">	Linear Dependance:</span>
<span class="sd">	&gt;&gt;&gt; ld_vec1 = np.array([1.0, 2.0, 4.0, 8.0])</span>
<span class="sd">	&gt;&gt;&gt; ld_vec2 = np.array([0.5, 1.0, 2.0, 4.0])</span>
<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(ld_vec1, ld_vec2)</span>
<span class="sd">	False</span>

<span class="sd">	Equal:</span>
<span class="sd">	&gt;&gt;&gt; e_vec1 = np.array([0.25, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; e_vec2 = np.array([0.25, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(e_vec1, e_vec2)</span>
<span class="sd">	False</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector2</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector2</span><span class="p">))</span>

<span class="c1">####################################################################################################</span>
<span class="c1"># JSON WRITING / LOADING</span>
<span class="c1">####################################################################################################</span>
<div class="viewcode-block" id="loader"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.loader">[docs]</a><span class="k">def</span> <span class="nf">loader</span><span class="p">(</span><span class="n">filepath</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Useful function for loading analyses into native python format (from a json).</span>

<span class="sd">	:param str filepath: path to analysis file in the databases/analyses directory.</span>
<span class="sd">	:return: analysis in native python types. Fragments and their associated onset range.</span>
<span class="sd">	:rtype: list</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_json</span><span class="p">:</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file_json</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">fragment</span><span class="o">.</span><span class="n">FragmentDecoder</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="write_analysis"><a class="viewcode-back" href="../../mods/utils.html#decitala.utils.write_analysis">[docs]</a><span class="k">def</span> <span class="nf">write_analysis</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Function for writing an `analysis` to JSON.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
		<span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">obj</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">fp</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="n">fragment</span><span class="o">.</span><span class="n">FragmentEncoder</span><span class="p">,</span> <span class="n">ensure_ascii</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020-2021, Luke Poeppel.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>