

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>decitala.utils &mdash; decitala 0.3.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="decitala 0.3.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> decitala
          

          
          </a>

          
            
            
              <div class="version">
                0.3.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../database.html">database.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fragment.html">fragment.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../paths.html">paths.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pofp.html">pofp.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../trees.html">trees.py</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../utils.html">utils.py</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">decitala</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>decitala.utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for decitala.utils</h1><div class="highlight"><pre>
<span></span><span class="c1">####################################################################################################</span>
<span class="c1"># File:     utils.py</span>
<span class="c1"># Purpose:  Random useful functions. </span>
<span class="c1"># </span>
<span class="c1"># Author:   Luke Poeppel</span>
<span class="c1">#</span>
<span class="c1"># Location: Kent, CT 2020 / Frankfurt, DE 2020</span>
<span class="c1">####################################################################################################</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">decimal</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">combinations</span><span class="p">,</span> <span class="n">groupby</span>
<span class="kn">from</span> <span class="nn">more_itertools</span> <span class="kn">import</span> <span class="n">consecutive_groups</span><span class="p">,</span> <span class="n">windowed</span><span class="p">,</span> <span class="n">powerset</span><span class="p">,</span> <span class="n">groupby_transform</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">chord</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">converter</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">note</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">spanner</span>
<span class="kn">from</span> <span class="nn">music21</span> <span class="kn">import</span> <span class="n">stream</span>

<span class="n">carnatic_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
	<span class="p">[</span><span class="s1">&#39;Druta&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Druta-Virama&#39;</span><span class="p">,</span> <span class="s1">&#39;oc&#39;</span><span class="p">,</span> <span class="mf">0.375</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Laghu&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Laghu-Virama&#39;</span><span class="p">,</span> <span class="s1">&#39;|c&#39;</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Guru&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Pluta&#39;</span><span class="p">,</span> <span class="s1">&#39;Sc&#39;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span>           <span class="c1"># Note: Normally a crescent moon superscript. Since it serves the same function as a virâma––we use the same notation. </span>
	<span class="c1">#[&#39;kakapadam&#39;, &#39;8X&#39;, 2.0]       # Decide what the appropriate convention is...</span>
<span class="p">])</span>

<span class="n">greek_diacritics</span> <span class="o">=</span> <span class="p">[</span>
	<span class="p">[</span><span class="s1">&#39;breve&#39;</span><span class="p">,</span> <span class="s1">&#39;⏑&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;macron&#39;</span><span class="p">,</span> <span class="s1">&#39;––&#39;</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">multiplicative_augmentations</span> <span class="o">=</span> <span class="p">[</span>
	<span class="p">[</span><span class="s1">&#39;Tiers&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Un quart&#39;</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Du Point&#39;</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Classique&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> 
	<span class="p">[</span><span class="s1">&#39;Double&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
	<span class="p">[</span><span class="s1">&#39;Triple&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="p">]</span>

<span class="c1">####################################################################################################</span>
<span class="c1"># Notational Conversion Functions</span>
<div class="viewcode-block" id="carnatic_string_to_ql_array"><a class="viewcode-back" href="../../utils.html#decitala.utils.carnatic_string_to_ql_array">[docs]</a><span class="k">def</span> <span class="nf">carnatic_string_to_ql_array</span><span class="p">(</span><span class="n">string_</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param str string_: string of carnatic durations separated by spaces. </span>
<span class="sd">	:return: input string converted to a quarter length array. </span>
<span class="sd">	:rtype: numpy.array. </span>
<span class="sd">	</span>
<span class="sd">	&gt;&gt;&gt; carnatic_string_to_ql_array(&#39;oc o | | Sc S o o o&#39;)</span>
<span class="sd">	array([0.375, 0.25 , 0.5  , 0.5  , 1.5  , 1.   , 0.25 , 0.25 , 0.25 ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">split_string</span> <span class="o">=</span> <span class="n">string_</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">this_carnatic_val</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">for</span> <span class="n">this_token</span> <span class="ow">in</span> <span class="n">split_string</span> <span class="k">for</span> <span class="n">this_carnatic_val</span> <span class="ow">in</span> <span class="n">carnatic_symbols</span> <span class="k">if</span> <span class="p">(</span><span class="n">this_carnatic_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">this_token</span><span class="p">)])</span></div>

<div class="viewcode-block" id="ql_array_to_carnatic_string"><a class="viewcode-back" href="../../utils.html#decitala.utils.ql_array_to_carnatic_string">[docs]</a><span class="k">def</span> <span class="nf">ql_array_to_carnatic_string</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param iterable ql_array: quarter length array. </span>
<span class="sd">	:return: quarter length array converted to carnatic notation.</span>
<span class="sd">	:rtype: str</span>
<span class="sd">	</span>
<span class="sd">	&gt;&gt;&gt; ql_array_to_carnatic_string([0.5, 0.25, 0.25, 0.375, 1.0, 1.5, 1.0, 0.5, 1.0])</span>
<span class="sd">	&#39;| o o oc S Sc S | S&#39;</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">this_carnatic_val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="n">ql_array</span> <span class="k">for</span> <span class="n">this_carnatic_val</span> <span class="ow">in</span> <span class="n">carnatic_symbols</span> <span class="k">if</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">this_carnatic_val</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="n">this_val</span><span class="p">)]))</span></div>

<div class="viewcode-block" id="ql_array_to_greek_diacritics"><a class="viewcode-back" href="../../utils.html#decitala.utils.ql_array_to_greek_diacritics">[docs]</a><span class="k">def</span> <span class="nf">ql_array_to_greek_diacritics</span><span class="p">(</span><span class="n">ql_array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns the input ``ql_array`` in greek prosodic notation. This notation only allows</span>
<span class="sd">	for two types of rhythmic values (long &amp; short). </span>

<span class="sd">	:param iterable ql_array: quarter length array. </span>
<span class="sd">	:return: quarter length array converted to greek prosodic notation.</span>
<span class="sd">	:rtype: str</span>

<span class="sd">	&gt;&gt;&gt; ql_array_to_greek_diacritics(ql_array=[1.0, 0.5, 0.5, 1.0, 1.0, 0.5])</span>
<span class="sd">	&#39;–– ⏑ ⏑ –– –– ⏑&#39;</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">ql_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span> <span class="c1"># Ensures native numpy type.</span>
	<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ql_array</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span>

	<span class="n">long_val</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">short_val</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ql_array</span><span class="p">)</span>
	<span class="n">long_factor</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">long_val</span>
	<span class="n">short_factor</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">short_val</span>

	<span class="n">ql_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span> <span class="o">*</span> <span class="n">long_factor</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">long_val</span> <span class="k">else</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">short_factor</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">])</span>
	<span class="n">greek_string_lst</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="n">ql_array</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">this_diacritic_name</span><span class="p">,</span> <span class="n">this_diacritic_symbol</span><span class="p">,</span> <span class="n">this_diacritic_val</span> <span class="ow">in</span> <span class="n">greek_diacritics</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">this_val</span> <span class="o">==</span> <span class="n">this_diacritic_val</span><span class="p">:</span>
				<span class="n">greek_string_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_diacritic_symbol</span><span class="p">)</span>

	<span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">greek_string_lst</span><span class="p">)</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># Rhythm helpers</span>
<div class="viewcode-block" id="augment"><a class="viewcode-back" href="../../utils.html#decitala.utils.augment">[docs]</a><span class="k">def</span> <span class="nf">augment</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">difference</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns an augmentation in the style of Messiaen. If difference is set to 0.0, then the augmentation</span>
<span class="sd">	is multiplicative. If factor is set to 1.0, then augmentation is additive. If factor &amp; difference are</span>
<span class="sd">	non-zero, we have a mixed augmentation. </span>

<span class="sd">	:param numpy.array fragment: array defining the rhythmic fragment.</span>
<span class="sd">	:param float factor: factor for multiplicative augmentation.</span>
<span class="sd">	:param float difference: factor for additive augmentation.</span>

<span class="sd">	:return: an augmented fragment.</span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; augment(fragment=[1.0, 1.0, 0.5, 0.25], factor=2.0, difference=0.25)</span>
<span class="sd">	array([2.25, 2.25, 1.25, 0.75])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;=</span> <span class="mf">0.0</span>
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">this_val</span> <span class="o">*</span> <span class="n">factor</span><span class="p">)</span> <span class="o">+</span> <span class="n">difference</span> <span class="k">for</span> <span class="n">this_val</span> <span class="ow">in</span> <span class="n">fragment</span><span class="p">])</span></div>

<div class="viewcode-block" id="successive_ratio_array"><a class="viewcode-back" href="../../utils.html#decitala.utils.successive_ratio_array">[docs]</a><span class="k">def</span> <span class="nf">successive_ratio_array</span><span class="p">(</span><span class="n">fragment</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns array defined by the ratio of successive elements. By convention, we set the first value to 1.0.</span>

<span class="sd">	:param numpy.array fragment: array defining a rhythmic fragment.</span>
<span class="sd">	:return: array consisting of successive ratios of the input elements. </span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; successive_ratio_array([1.0, 1.0, 2.0, 0.5, 0.5, 0.25, 1.0])</span>
<span class="sd">	array([1.  , 1.  , 2.  , 0.25, 1.  , 0.5 , 4.  ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">_ratio</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the ratio of an element in an array at index i to the value at index i + 1.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start_index</span> <span class="ow">and</span> <span class="n">start_index</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Input ``start_index`` not in appropriate range!&#39;</span><span class="p">)</span>
		<span class="k">try</span><span class="p">:</span> 
			<span class="n">ratio</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">array</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span>
			<span class="k">return</span> <span class="nb">round</span><span class="p">(</span><span class="n">ratio</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;There is a 0 at some point in the input array.&quot;</span><span class="p">)</span>

	<span class="n">ratio_lst</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">ratio_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ratio</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratio_lst</span><span class="p">)</span></div>

<div class="viewcode-block" id="successive_difference_array"><a class="viewcode-back" href="../../utils.html#decitala.utils.successive_difference_array">[docs]</a><span class="k">def</span> <span class="nf">successive_difference_array</span><span class="p">(</span><span class="n">fragment</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns the first order difference of ``fragment`` (contiguous differences). </span>

<span class="sd">	:param numpy.array fragment: array defining a rhythmic fragment.</span>
<span class="sd">	:return: array consisting of successive differences of the input elements. </span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; successive_difference_array([0.25, 0.25, 0.75, 0.75, 0.5, 1.0, 1.5])</span>
<span class="sd">	array([ 0.  ,  0.  ,  0.5 ,  0.  , -0.25,  0.5 ,  0.5 ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">_difference</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start_index</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Returns the difference between two elements.&quot;&quot;&quot;</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="n">difference</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">array</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span>
			<span class="k">return</span> <span class="n">difference</span>
		<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
			<span class="k">pass</span>

	<span class="n">difference_lst</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">difference_lst</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_difference</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">difference_lst</span><span class="p">)</span></div>

<span class="c1"># def contiguous_multiplication(array):</span>
<span class="c1"># 	&quot;&quot;&quot;</span>
<span class="c1"># 	Takes the zeroth value in the array and successively multiplies by the next value. As </span>
<span class="c1"># 	such, the dimension of the output vector is :math:`n + 1` for :math:`n` the original dimension.</span>

<span class="c1"># 	:param numpy.array fragment: arbitrary array.</span>
<span class="c1"># 	:return: array consisting of the successive product of the elements in the array.</span>
<span class="c1"># 	:rtype: numpy.array</span>

<span class="c1"># 	&gt;&gt;&gt; ex = np.array([-1, 0.5, -3])</span>
<span class="c1"># 	&gt;&gt;&gt; contiguous_multiplication(ex)</span>
<span class="c1"># 	array([-1. ,  1. ,  0.5, -1.5])</span>
<span class="c1"># 	&quot;&quot;&quot;</span>
<span class="c1"># 	out = [array[0]]</span>
<span class="c1"># 	i = 0</span>
<span class="c1"># 	while i &lt; len(array) - 1:</span>
<span class="c1"># 		if i == 0:</span>
<span class="c1"># 			first_elem_squared = array[i]**2</span>
<span class="c1"># 			out.append(first_elem_squared)</span>
<span class="c1"># 			out.append(first_elem_squared * array[i + 1])</span>
<span class="c1"># 		else:</span>
<span class="c1"># 			out.append(array[i] * array[i + 1])</span>
<span class="c1"># 		i += 1 </span>
<span class="c1"># 	return np.array(out)</span>

<span class="c1">####################################################################################################</span>
<span class="c1"># Subdivision</span>
<div class="viewcode-block" id="find_clusters"><a class="viewcode-back" href="../../utils.html#decitala.utils.find_clusters">[docs]</a><span class="k">def</span> <span class="nf">find_clusters</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">data_mode</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Finds the regions with consecutive equal elements.</span>

<span class="sd">	:param iterable input_: either a list/array (representing :obj:`~decitala.fragment.GeneralFragment.ql_array`) </span>
<span class="sd">							or data from :obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:param bool data_mode: whether or not the input data is a quarter length array or data from </span>
<span class="sd">							:obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:return: a list of cluster indices; if not in data mode, regions with equal quarter length values;</span>
<span class="sd">			if ``data_mode=True``, then regions where the quarter lengths and pitch content are equal. </span>

<span class="sd">	&gt;&gt;&gt; varied_ragavardhana = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; clusters = find_clusters(varied_ragavardhana)</span>
<span class="sd">	&gt;&gt;&gt; clusters</span>
<span class="sd">	[[0, 2], [4, 5], [7, 9]]</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana[clusters[0][0]:clusters[0][1]+1]</span>
<span class="sd">	array([1., 1., 1.])</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana[clusters[1][0]:clusters[1][1]+1]</span>
<span class="sd">	array([0.75, 0.75])</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana[clusters[2][0]:clusters[2][1]+1]</span>
<span class="sd">	array([0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; # We can also find clusters of pitch and rhythmic information for data from :obj:`~decitala.utils.get_object_indices`. </span>
<span class="sd">	&gt;&gt;&gt; example_data = [</span>
<span class="sd">	...		(note.Note(&quot;F#&quot;), (6.5, 6.75)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (6.75, 7.0)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.0, 7.25)), </span>
<span class="sd">	...     (note.Note(&quot;C#&quot;), (7.25, 7.5)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.5, 7.75)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.75, 8.0)), </span>
<span class="sd">	...     (note.Note(&quot;A-&quot;), (8.0, 8.125)), </span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; find_clusters(example_data, data_mode=True)</span>
<span class="sd">	[[1, 2], [4, 5]]</span>
<span class="sd">	&gt;&gt;&gt; example_data2 = [</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.0, 0.125)), </span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.125, 0.25)), </span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.25, 0.375)), </span>
<span class="sd">	... 	(chord.Chord([&quot;E-3&quot;, &quot;D4&quot;], quarterLength=0.125), (0.375, 0.5)), </span>
<span class="sd">	... 	(chord.Chord([&quot;A2&quot;, &quot;A-3&quot;], quarterLength=0.25), (0.5, 0.75)), </span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; find_clusters(example_data2, data_mode=True)</span>
<span class="sd">	[[0, 2]]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">data_mode</span><span class="p">):</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">)),</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">regions_property</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">midi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pitches</span><span class="p">])</span>
		<span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_</span><span class="p">)),</span> <span class="n">regions_property</span><span class="p">)]</span>

	<span class="n">cluster_index_ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">this_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">cluster_index_ranges</span></div>

<span class="k">def</span> <span class="nf">_compliment_of_index_ranges</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">clusters</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	TODO: if the compliment range has only one val, it should just be one val, not two (otherwise can&#39;t distinguish). </span>

<span class="sd">	&gt;&gt;&gt; varied_ragavardhana = np.array([1, 1, 1, 0.5, 0.75, 0.5])</span>
<span class="sd">	&gt;&gt;&gt; _compliment_of_index_ranges(varied_ragavardhana, [find_clusters(varied_ragavardhana)[0]]) </span>
<span class="sd">	[[3, 5]]</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana_2 = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; _compliment_of_index_ranges(varied_ragavardhana_2, find_clusters(varied_ragavardhana_2))</span>
<span class="sd">	[[3], [6]]</span>
<span class="sd">	&gt;&gt;&gt; </span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">flattened_cluster_ranges</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
		<span class="n">index_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">this_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
		<span class="n">flattened_cluster_ranges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">index_range</span><span class="p">)</span>

	<span class="n">total_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)))</span>
	<span class="n">diff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">total_range</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">flattened_cluster_ranges</span><span class="p">)))</span>

	<span class="n">compliments</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">consecutive_groups</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
		<span class="n">elem_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elem_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">compliments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elem_list</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">compliments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">elem_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">elem_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

	<span class="k">return</span> <span class="n">compliments</span>

<span class="k">def</span> <span class="nf">_make_one_superdivision</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">clusters</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana_2 = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; c = find_clusters(varied_ragavardhana_2)</span>
<span class="sd">	&gt;&gt;&gt; # one combination of the clusters is [[0, 2], [7, 9]]</span>
<span class="sd">	&gt;&gt;&gt; _make_one_superdivision(varied_ragavardhana_2, [[0, 2], [7, 9]])</span>
<span class="sd">	array([3.  , 0.5 , 0.75, 0.75, 0.5 , 0.75])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">superdivision</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
	<span class="n">compliment_ranges</span> <span class="o">=</span> <span class="n">_compliment_of_index_ranges</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">compliment_ranges</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">superdivision</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">superdivision</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">for</span> <span class="n">this_cluster</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">:</span>
		<span class="n">region</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">this_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">this_cluster</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># this is good too! </span>
		<span class="n">summed</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
		<span class="n">superdivision</span><span class="p">[</span><span class="n">this_cluster</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">summed</span> <span class="c1"># this is the problem. </span>
		
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">superdivision</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
	
<div class="viewcode-block" id="find_possible_superdivisions"><a class="viewcode-back" href="../../utils.html#decitala.utils.find_possible_superdivisions">[docs]</a><span class="k">def</span> <span class="nf">find_possible_superdivisions</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	There is a more general approach to the subdivision problem, but we note that Messiaen&#39;s subdivision</span>
<span class="sd">	of tala components tends to be even. </span>

<span class="sd">	&gt;&gt;&gt; varied_ragavardhana = np.array([1, 1, 1, 0.5, 0.75, 0.5])</span>
<span class="sd">	&gt;&gt;&gt; for x in find_possible_superdivisions(varied_ragavardhana):</span>
<span class="sd">	...     print(x)</span>
<span class="sd">	[1.   1.   1.   0.5  0.75 0.5 ]</span>
<span class="sd">	[3.   0.5  0.75 0.5 ]</span>
<span class="sd">	</span>
<span class="sd">	&gt;&gt;&gt; varied_ragavardhana_2 = np.array([1, 1, 1, 0.5, 0.75, 0.75, 0.5, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; for x in find_possible_superdivisions(varied_ragavardhana_2):</span>
<span class="sd">	...     print(x)</span>
<span class="sd">	[1.   1.   1.   0.5  0.75 0.75 0.5  0.25 0.25 0.25]</span>
<span class="sd">	[3.   0.5  0.75 0.75 0.5  0.25 0.25 0.25]</span>
<span class="sd">	[1.   1.   1.   0.5  1.5  0.5  0.25 0.25 0.25]</span>
<span class="sd">	[1.   1.   1.   0.5  0.75 0.75 0.5  0.75]</span>
<span class="sd">	[3.   0.5  1.5  0.5  0.25 0.25 0.25]</span>
<span class="sd">	[3.   0.5  0.75 0.75 0.5  0.75]</span>
<span class="sd">	[1.   1.   1.   0.5  1.5  0.5  0.75]</span>
<span class="sd">	[3.   0.5  1.5  0.5  0.75]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">possible_super_divisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span>
	<span class="n">clusters</span> <span class="o">=</span> <span class="n">find_clusters</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
	<span class="n">possible_combinations</span> <span class="o">=</span> <span class="n">power_list</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">this_combination</span> <span class="ow">in</span> <span class="n">possible_combinations</span><span class="p">:</span>
		<span class="n">superdivision</span> <span class="o">=</span> <span class="n">_make_one_superdivision</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">this_combination</span><span class="p">)</span>
		<span class="n">possible_super_divisions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">superdivision</span><span class="p">)</span>
	
	<span class="k">return</span> <span class="n">possible_super_divisions</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># La Valeur Ajoutee</span>
<span class="k">def</span> <span class="nf">get_added_values</span><span class="p">(</span><span class="n">ql_lst</span><span class="p">,</span> <span class="n">print_type</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Given a quarter length list, returns all indices and types of added values found, according to </span>
<span class="sd">	the examples dicussed in Technique de Mon Langage Musical (1944). </span>

<span class="sd">	&gt;&gt;&gt; get_added_values([0.25, 0.5, 0.5, 0.75, 0.25])</span>
<span class="sd">	[(0, &#39;du Note&#39;), (4, &#39;du Note&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.25, 0.5, 0.25, 1.0])</span>
<span class="sd">	[(1, &#39;du Note&#39;), (3, &#39;du Note&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.75, 0.75, 0.75, 0.25, 0.5])</span>
<span class="sd">	[(3, &#39;du Note&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.75, 0.75, 0.75, 0.75, 0.25, 0.25])</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.25, 0.5, 0.75, 1.25, 1.5])</span>
<span class="sd">	[(1, &#39;du Note&#39;), (3, &#39;du Point&#39;), (4, &#39;du Tie&#39;)]</span>

<span class="sd">	&gt;&gt;&gt; l = [1.0, 0.5, 0.25, 1.0, 0.5, 0.75, 0.5]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values(l)</span>
<span class="sd">	[(2, &#39;du Note&#39;), (5, &#39;du Point&#39;)]</span>

<span class="sd">	?????</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.5, 0.75, 1.25, 0.75])</span>
<span class="sd">	[(2, &#39;du Point&#39;), (3, &#39;du Tie&#39;)]</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([1.0, 0.25, 0.5], print_type = False)</span>
<span class="sd">	[1]</span>

<span class="sd">	&gt;&gt;&gt; get_added_values([0.25, 0.25, 0.75, 2.0])</span>
<span class="sd">	[(2, &#39;du Point&#39;)]</span>
<span class="sd">	&gt;&gt;&gt; get_added_values([0.5, 0.25, 0.75, 0.25, 0.5])</span>
<span class="sd">	[(1, &#39;du Note&#39;), (2, &#39;du Point&#39;), (3, &#39;du Note&#39;)]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ql_lst</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;List must be of length 3 or greater.&#39;</span><span class="p">)</span>

	<span class="n">addedVals</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">if</span> <span class="n">ql_lst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.25</span> <span class="ow">and</span> <span class="n">ql_lst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.25</span><span class="p">:</span>
		<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">ql_lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.25</span> <span class="ow">and</span> <span class="n">ql_lst</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">0.25</span><span class="p">:</span>
		<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ql_lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">ql_lst</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.75</span> <span class="ow">and</span> <span class="n">ql_lst</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ql_lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>

	<span class="k">for</span> <span class="n">currIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ql_lst</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">prevVal</span> <span class="o">=</span> <span class="n">ql_lst</span><span class="p">[</span><span class="n">currIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
		<span class="n">currVal</span> <span class="o">=</span> <span class="n">ql_lst</span><span class="p">[</span><span class="n">currIndex</span><span class="p">]</span>
		<span class="n">nextVal</span> <span class="o">=</span> <span class="n">ql_lst</span><span class="p">[</span><span class="n">currIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

		<span class="n">x</span> <span class="o">=</span> <span class="n">currVal</span> <span class="o">-</span> <span class="mf">0.25</span>
		<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">is_integer</span><span class="p">():</span>
			<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Tie&#39;</span><span class="p">))</span>

		<span class="k">if</span> <span class="n">currVal</span> <span class="o">==</span> <span class="mf">0.25</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">prevVal</span> <span class="o">!=</span> <span class="n">currVal</span> <span class="o">!=</span> <span class="n">nextVal</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">prevVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nextVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
				<span class="k">elif</span> <span class="n">prevVal</span> <span class="o">%</span> <span class="mf">0.75</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
				<span class="k">elif</span> <span class="n">nextVal</span> <span class="o">%</span> <span class="mf">0.75</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Note&#39;</span><span class="p">))</span>
		<span class="k">elif</span> <span class="n">currVal</span> <span class="o">==</span> <span class="mf">0.75</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">prevVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">nextVal</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">prevVal</span> <span class="o">&lt;</span> <span class="n">currVal</span> <span class="ow">and</span> <span class="n">nextVal</span> <span class="o">&gt;</span> <span class="n">currVal</span><span class="p">:</span>
				<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>
			<span class="k">elif</span> <span class="n">prevVal</span> <span class="o">==</span> <span class="mf">0.25</span><span class="p">:</span>
				<span class="n">addedVals</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">currIndex</span><span class="p">,</span> <span class="s1">&#39;du Point&#39;</span><span class="p">))</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">addedVals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">None</span>

	<span class="k">if</span> <span class="n">print_type</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">addedVals</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">addedVals</span>

<span class="c1">#NOTE: Double check this works.</span>
<span class="k">def</span> <span class="nf">removeAddedValuesFromList</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
	<span class="n">added_val_indices</span> <span class="o">=</span> <span class="n">get_added_values</span><span class="p">(</span><span class="n">ql_lst</span><span class="o">=</span><span class="n">lst</span><span class="p">,</span> <span class="n">print_type</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">added_val_indices</span><span class="p">:</span>
		<span class="k">del</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

	<span class="k">return</span> <span class="n">lst</span>

<span class="c1">####################################################################################################</span>
<span class="c1"># Windowing</span>
<div class="viewcode-block" id="roll_window"><a class="viewcode-back" href="../../utils.html#decitala.utils.roll_window">[docs]</a><span class="k">def</span> <span class="nf">roll_window</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">window_length</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Takes in a list and returns a numpy vstack holding rolling windows of length ``window_length``.</span>

<span class="sd">	:param numpy.array array: an iterable</span>
<span class="sd">	:return: rolling windows of array, each of length `window_length`. </span>
<span class="sd">	:rtype: numpy.vstack</span>

<span class="sd">	&gt;&gt;&gt; composers = np.array([&#39;Mozart&#39;, &#39;Monteverdi&#39;, &#39;Messiaen&#39;, &#39;Mahler&#39;, &#39;MacDowell&#39;, &#39;Massenet&#39;])</span>
<span class="sd">	&gt;&gt;&gt; for window in roll_window(array=composers, window_length=3):</span>
<span class="sd">	...     print(window)</span>
<span class="sd">	(&#39;Mozart&#39;, &#39;Monteverdi&#39;, &#39;Messiaen&#39;)</span>
<span class="sd">	(&#39;Monteverdi&#39;, &#39;Messiaen&#39;, &#39;Mahler&#39;)</span>
<span class="sd">	(&#39;Messiaen&#39;, &#39;Mahler&#39;, &#39;MacDowell&#39;)</span>
<span class="sd">	(&#39;Mahler&#39;, &#39;MacDowell&#39;, &#39;Massenet&#39;)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">window_length</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span>
	<span class="n">windows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">windowed</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">window_length</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
	<span class="k">return</span> <span class="n">windows</span></div>

<div class="viewcode-block" id="power_list"><a class="viewcode-back" href="../../utils.html#decitala.utils.power_list">[docs]</a><span class="k">def</span> <span class="nf">power_list</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param data: an iterable</span>
<span class="sd">	:return: power set of the data as a list (excluding the empty list).</span>
<span class="sd">	:rtype: list</span>

<span class="sd">	&gt;&gt;&gt; l = [1, 2, 3]</span>
<span class="sd">	&gt;&gt;&gt; power_list(l)</span>
<span class="sd">	[(1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]</span>

<span class="sd">	&gt;&gt;&gt; for x in power_list([(0.0, 2.0), (4.0, 5.5), (6.0, 7.25)]):</span>
<span class="sd">	...     print(x)</span>
<span class="sd">	((0.0, 2.0),)</span>
<span class="sd">	((4.0, 5.5),)</span>
<span class="sd">	((6.0, 7.25),)</span>
<span class="sd">	((0.0, 2.0), (4.0, 5.5))</span>
<span class="sd">	((0.0, 2.0), (6.0, 7.25))</span>
<span class="sd">	((4.0, 5.5), (6.0, 7.25))</span>
<span class="sd">	((0.0, 2.0), (4.0, 5.5), (6.0, 7.25))</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span>
	<span class="n">power_list</span> <span class="o">=</span> <span class="n">powerset</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">power_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span></div>

<span class="c1">####################################################################################################</span>
<span class="c1"># Math helpers</span>
<span class="k">def</span> <span class="nf">cauchy_schwartz</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Tests the Cauchy-Schwartz inequality on two vectors. Namely, if the absolute value of </span>
<span class="sd">	the dot product of the two vectors is less than the product of the norms, the vectors are </span>
<span class="sd">	linearly independant (and the function returns True); if they are equal, they are dependant </span>
<span class="sd">	(and the function returns False). </span>

<span class="sd">	Linear Independence:</span>
<span class="sd">	&gt;&gt;&gt; li_vec1 = np.array([0.375, 1.0, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; li_vec2 = np.array([1.0, 0.0, 0.5])</span>
<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(li_vec1, li_vec2)</span>
<span class="sd">	True</span>

<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(np.array([0.75, 0.5]), np.array([1.5, 1.0]))</span>
<span class="sd">	False</span>

<span class="sd">	Linear Dependance:</span>
<span class="sd">	&gt;&gt;&gt; ld_vec1 = np.array([1.0, 2.0, 4.0, 8.0])</span>
<span class="sd">	&gt;&gt;&gt; ld_vec2 = np.array([0.5, 1.0, 2.0, 4.0])</span>
<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(ld_vec1, ld_vec2)</span>
<span class="sd">	False</span>

<span class="sd">	Equal:</span>
<span class="sd">	&gt;&gt;&gt; e_vec1 = np.array([0.25, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; e_vec2 = np.array([0.25, 0.25, 0.25, 0.25])</span>
<span class="sd">	&gt;&gt;&gt; cauchy_schwartz(e_vec1, e_vec2)</span>
<span class="sd">	False</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">vector2</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector1</span><span class="p">,</span> <span class="n">vector2</span><span class="p">))</span> <span class="o">&lt;</span>  <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">vector1</span><span class="p">)</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">vector2</span><span class="p">))</span>

<span class="c1">####################################################################################################</span>
<span class="c1"># Score helpers</span>
<div class="viewcode-block" id="get_object_indices"><a class="viewcode-back" href="../../utils.html#decitala.utils.get_object_indices">[docs]</a><span class="k">def</span> <span class="nf">get_object_indices</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">part_num</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Returns data of the form [(object, (start, end)), ...] for a given file path and part number. </span>
<span class="sd">	(Supports rests and grace notes.)</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">score</span> <span class="o">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>
	<span class="n">part</span> <span class="o">=</span> <span class="n">score</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="n">part_num</span><span class="p">]</span>
	<span class="n">data_out</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">stripped</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">stripTies</span><span class="p">(</span><span class="n">retainContainers</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">this_obj</span> <span class="ow">in</span> <span class="n">stripped</span><span class="o">.</span><span class="n">recurse</span><span class="p">()</span><span class="o">.</span><span class="n">iter</span><span class="o">.</span><span class="n">notesAndRests</span><span class="p">:</span>
		<span class="n">data_out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">this_obj</span><span class="p">,</span> <span class="p">(</span><span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">)))</span>

	<span class="k">return</span> <span class="n">data_out</span></div>

<div class="viewcode-block" id="contiguous_summation"><a class="viewcode-back" href="../../utils.html#decitala.utils.contiguous_summation">[docs]</a><span class="k">def</span> <span class="nf">contiguous_summation</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	Given some ``data`` from :obj:`~decitala.utils.get_object_indices`, finds every location where the pitch and </span>
<span class="sd">	rhythmic material are contiguously equal and sums these regions. </span>
<span class="sd">	</span>
<span class="sd">	&gt;&gt;&gt; example_data = [</span>
<span class="sd">	...		(note.Note(&quot;F#&quot;), (6.5, 6.75)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (6.75, 7.0)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.0, 7.25)), </span>
<span class="sd">	...     (note.Note(&quot;C#&quot;), (7.25, 7.5)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.5, 7.75)), </span>
<span class="sd">	...     (note.Note(&quot;G&quot;), (7.75, 8.0)), </span>
<span class="sd">	...     (note.Note(&quot;A-&quot;), (8.0, 8.125)), </span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; for this_object in contiguous_summation(example_data):</span>
<span class="sd">	...     print(this_object)</span>
<span class="sd">	(&lt;music21.note.Note F#&gt;, (6.5, 6.75))</span>
<span class="sd">	(&lt;music21.note.Note G&gt;, (6.75, 7.25))</span>
<span class="sd">	(&lt;music21.note.Note C#&gt;, (7.25, 7.5))</span>
<span class="sd">	(&lt;music21.note.Note G&gt;, (7.5, 8.0))</span>
<span class="sd">	(&lt;music21.note.Note A-&gt;, (8.0, 8.125))</span>
<span class="sd">	&gt;&gt;&gt; # Also works with chords.</span>
<span class="sd">	&gt;&gt;&gt; example_data2 = [</span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.0, 0.125)), </span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.125, 0.25)), </span>
<span class="sd">	... 	(chord.Chord([&quot;F#2&quot;, &quot;F3&quot;], quarterLength=0.125), (0.25, 0.375)), </span>
<span class="sd">	... 	(chord.Chord([&quot;E-3&quot;, &quot;D4&quot;], quarterLength=0.125), (0.375, 0.5)), </span>
<span class="sd">	... 	(chord.Chord([&quot;A2&quot;, &quot;A-3&quot;], quarterLength=0.25), (0.5, 0.75)), </span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; sum_search = contiguous_summation(example_data2)</span>
<span class="sd">	&gt;&gt;&gt; for this_object in sum_search:</span>
<span class="sd">	...     print(this_object)</span>
<span class="sd">	(&lt;music21.chord.Chord F#2 F3&gt;, (0.0, 0.375))</span>
<span class="sd">	(&lt;music21.chord.Chord E-3 D4&gt;, (0.375, 0.5))</span>
<span class="sd">	(&lt;music21.chord.Chord A2 A-3&gt;, (0.5, 0.75))</span>
<span class="sd">	&gt;&gt;&gt; # The quarter lengths of the objects change according to the new summation. </span>
<span class="sd">	&gt;&gt;&gt; for this_object in sum_search:</span>
<span class="sd">	... 	print(this_object[0].quarterLength)</span>
<span class="sd">	0.375</span>
<span class="sd">	0.125</span>
<span class="sd">	0.25</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">copied_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
	<span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="n">regions_property</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">((</span><span class="n">copied_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">midi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pitches</span><span class="p">])</span>
	<span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">copied_data</span><span class="p">)),</span> <span class="n">regions_property</span><span class="p">)]</span>
		
	<span class="n">cluster_index_ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">this_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_range</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">ranges</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">this_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
	<span class="n">compliment_ranges</span> <span class="o">=</span> <span class="n">_compliment_of_index_ranges</span><span class="p">(</span><span class="n">copied_data</span><span class="p">,</span> <span class="n">cluster_index_ranges</span><span class="p">)</span>
	
	<span class="n">new_objects</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">copied_data</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">this_index_range</span> <span class="ow">in</span> <span class="n">cluster_index_ranges</span><span class="p">:</span>
		<span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">this_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_index_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
		<span class="n">start_offset</span> <span class="o">=</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">stop_offset</span> <span class="o">=</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">stop</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		
		<span class="n">pitch_data</span> <span class="o">=</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">summed_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">pitch_data</span><span class="p">,</span> <span class="p">(</span><span class="n">start_offset</span><span class="p">,</span> <span class="n">stop_offset</span><span class="p">))</span>
		
		<span class="n">new_objects</span><span class="p">[</span><span class="n">this_index_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">summed_data</span>
	
	<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">compliment_ranges</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">new_objects</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">new_objects</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">copied_data</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
	
	<span class="n">new_objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_objects</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

	<span class="k">for</span> <span class="n">this_data</span> <span class="ow">in</span> <span class="n">new_objects</span><span class="p">:</span>
		<span class="n">new_ql</span> <span class="o">=</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">this_data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="n">this_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">quarterLength</span> <span class="o">=</span> <span class="n">new_ql</span>
		
	<span class="k">return</span> <span class="n">new_objects</span></div>

<div class="viewcode-block" id="frame_to_ql_array"><a class="viewcode-back" href="../../utils.html#decitala.utils.frame_to_ql_array">[docs]</a><span class="k">def</span> <span class="nf">frame_to_ql_array</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list frame: frame of data from :obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:return: numpy array holding the associated quarter length of a given window. </span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; my_frame = [</span>
<span class="sd">	...     (note.Note(&quot;B-&quot;, quarterLength=0.125), (4.125, 4.25)), </span>
<span class="sd">	...		(note.Note(&quot;A&quot;, quarterLength=0.25), (4.25, 4.5)), </span>
<span class="sd">	...		(note.Note(&quot;B&quot;, quarterLength=0.125), (4.5, 4.625)), </span>
<span class="sd">	...		(note.Note(&quot;B-&quot;, quarterLength=0.125), (4.625, 4.75)), </span>
<span class="sd">	...		(note.Note(&quot;A&quot;, quarterLength=0.25), (4.75, 5.0)), </span>
<span class="sd">	...		(note.Note(&quot;G&quot;, quarterLength=0.25), (5.0, 5.25)), </span>
<span class="sd">	...		(note.Note(&quot;G&quot;, quarterLength=0.25), (5.25, 5.5)), </span>
<span class="sd">	...	]</span>
<span class="sd">	&gt;&gt;&gt; frame_to_ql_array(my_frame)</span>
<span class="sd">	array([0.125, 0.25 , 0.125, 0.125, 0.25 , 0.25 , 0.25 ])</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">qls</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_obj</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">:</span>
		<span class="n">qls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_obj</span><span class="o">.</span><span class="n">quarterLength</span><span class="p">)</span>
	
	<span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">qls</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="frame_to_midi"><a class="viewcode-back" href="../../utils.html#decitala.utils.frame_to_midi">[docs]</a><span class="k">def</span> <span class="nf">frame_to_midi</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">ignore_graces</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list frame: frame of data from :obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:return: numpy array holding the pitches within the frame. </span>
<span class="sd">	:rtype: numpy.array</span>

<span class="sd">	&gt;&gt;&gt; my_frame = [</span>
<span class="sd">	...     (note.Note(&quot;B-&quot;, quarterLength=0.125), (4.125, 4.25)), </span>
<span class="sd">	...		(note.Note(&quot;A&quot;, quarterLength=0.25), (4.25, 4.5)), </span>
<span class="sd">	...		(note.Note(&quot;B&quot;, quarterLength=0.125), (4.5, 4.625)), </span>
<span class="sd">	...		(note.Note(&quot;B-&quot;, quarterLength=0.125), (4.625, 4.75)), </span>
<span class="sd">	...		(note.Note(&quot;A&quot;, quarterLength=0.25), (4.75, 5.0)), </span>
<span class="sd">	...		(note.Note(&quot;G&quot;, quarterLength=0.25), (5.0, 5.25)), </span>
<span class="sd">	...		(note.Note(&quot;G&quot;, quarterLength=0.25), (5.25, 5.5)), </span>
<span class="sd">	...	]</span>
<span class="sd">	&gt;&gt;&gt; frame_to_midi(my_frame)</span>
<span class="sd">	[(70,), (69,), (71,), (70,), (69,), (67,), (67,)]</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c1"># TODO: make midi</span>
	<span class="n">midi_out</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">this_obj</span><span class="p">,</span> <span class="n">this_range</span> <span class="ow">in</span> <span class="n">frame</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">ignore_graces</span><span class="p">):</span> <span class="c1"># add everything</span>
			<span class="n">fpitches</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">pitches</span>
			<span class="n">midi_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">midi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fpitches</span><span class="p">]))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">quarterLength</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
				<span class="k">pass</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">fpitches</span> <span class="o">=</span> <span class="n">this_obj</span><span class="o">.</span><span class="n">pitches</span>
				<span class="n">midi_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">midi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fpitches</span><span class="p">]))</span>

	<span class="k">return</span> <span class="n">midi_out</span></div>

<div class="viewcode-block" id="frame_is_spanned_by_slur"><a class="viewcode-back" href="../../utils.html#decitala.utils.frame_is_spanned_by_slur">[docs]</a><span class="k">def</span> <span class="nf">frame_is_spanned_by_slur</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list frame: frame from :obj:`~decitala.utils.get_object_indices`.</span>
<span class="sd">	:return: whether or not the frame is spanned by a music21.spanner.Slur object.</span>
<span class="sd">	:rtype: bool</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">is_spanned_by_slur</span> <span class="o">=</span> <span class="kc">False</span>

	<span class="n">first_obj</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">last_obj</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">spanners</span> <span class="o">=</span> <span class="n">first_obj</span><span class="o">.</span><span class="n">getSpannerSites</span><span class="p">()</span>
	<span class="k">if</span> <span class="n">spanners</span><span class="p">:</span>
		<span class="k">if</span> <span class="s2">&quot;Slur&quot;</span> <span class="ow">in</span> <span class="n">spanners</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">classes</span><span class="p">:</span>
			<span class="n">slur_spanner</span> <span class="o">=</span> <span class="n">spanners</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">slur_spanner</span><span class="o">.</span><span class="n">isFirst</span><span class="p">(</span><span class="n">first_obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">slur_spanner</span><span class="o">.</span><span class="n">isLast</span><span class="p">(</span><span class="n">last_obj</span><span class="p">):</span>
				<span class="n">is_spanned_by_slur</span> <span class="o">=</span> <span class="kc">True</span>

	<span class="k">return</span> <span class="n">is_spanned_by_slur</span></div>

<div class="viewcode-block" id="filter_single_anga_class_fragments"><a class="viewcode-back" href="../../utils.html#decitala.utils.filter_single_anga_class_fragments">[docs]</a><span class="k">def</span> <span class="nf">filter_single_anga_class_fragments</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list data: data from :obj:`~decitala.trees.rolling_search`.</span>
<span class="sd">	:return: data from the input with all single-anga-class talas removed. For information on anga-class, see: </span>
<span class="sd">			:obj:`decitala.fragment.Decitala.num_anga_classes`.</span>
<span class="sd">	:rtype: list</span>

<span class="sd">	&gt;&gt;&gt; from decitala.fragment import GreekFoot</span>
<span class="sd">	&gt;&gt;&gt; data = [</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.0, 0.5), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(80,), (91,)]},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Trochee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,)]},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.0625), &#39;onset_range&#39;: (0.5, 0.75), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(78,), (85,)]},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Iamb&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.625, 1.0), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(85,), (93,)]},</span>
<span class="sd">	... 	{&#39;fragment&#39;: GreekFoot(&quot;Spondee&quot;), &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.75, 1.25), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(93,), (91,)]}</span>
<span class="sd">	... ]</span>
<span class="sd">	&gt;&gt;&gt; filtered = filter_single_anga_class_fragments(data)</span>
<span class="sd">	&gt;&gt;&gt; for x in filtered:</span>
<span class="sd">	... 	print(x)</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Trochee&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.25, 0.625), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(91,), (78,)]}</span>
<span class="sd">	{&#39;fragment&#39;: &lt;fragment.GreekFoot Iamb&gt;, &#39;mod&#39;: (&#39;r&#39;, 0.125), &#39;onset_range&#39;: (0.625, 1.0), &#39;is_spanned_by_slur&#39;: False, &#39;pitch_content&#39;: [(85,), (93,)]}</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">num_anga_classes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span></div>

<div class="viewcode-block" id="filter_sub_fragments"><a class="viewcode-back" href="../../utils.html#decitala.utils.filter_sub_fragments">[docs]</a><span class="k">def</span> <span class="nf">filter_sub_fragments</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">filter_in_retrograde</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">	:param list data: data from :obj:`~decitala.trees.rolling_search`.</span>
<span class="sd">	:return: data from the input with all sub-talas removed; that is, talas that sit inside of another. </span>
<span class="sd">	:rtype: list</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="n">just_fragments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]))</span>

	<span class="k">def</span> <span class="nf">_check_all</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
		<span class="n">check</span> <span class="o">=</span> <span class="kc">False</span>
		<span class="k">for</span> <span class="n">this_fragment</span> <span class="ow">in</span> <span class="n">just_fragments</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">this_fragment</span><span class="o">.</span><span class="n">ql_array</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">ql_array</span><span class="p">()):</span>
				<span class="k">pass</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">is_sub_fragment</span><span class="p">(</span><span class="n">this_fragment</span><span class="p">,</span> <span class="n">filter_in_retrograde</span><span class="p">):</span>
					<span class="n">check</span> <span class="o">=</span> <span class="kc">True</span>
		<span class="k">return</span> <span class="n">check</span>

	<span class="n">filtered_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">just_fragments</span> <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">_check_all</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="s2">&quot;fragment&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">filtered_names</span><span class="p">]</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Luke Poeppel.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> and ❤️  using a custom <a href="https://github.com/LinxiFan/Sphinx-theme">theme</a> based on <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/language_data.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>